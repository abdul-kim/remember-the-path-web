<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REMEMBER The Path</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        
        :root {
            --theme-color: #38bdf8; /* Default Sky Blue */
            --theme-shadow: rgba(56, 189, 248, 0.5);
            --theme-shadow-soft: rgba(56, 189, 248, 0.3);
            --theme-ambient: rgba(56, 189, 248, 0.22);
            --surface-0: #0b1220;
            --surface-1: #111827;
            --surface-2: rgba(17, 24, 39, 0.92);
            --surface-3: #1f2937;
            --surface-4: #0f172a;
            --surface-hover: #273244;
            --border-soft: #1f2937;
            --border-strong: #334155;
            --text-strong: #e2e8f0;
            --text-muted: #94a3b8;
            --text-soft: #64748b;
            --text-faint: #475569;
            --radius-lg: 16px;
            --radius-md: 12px;
            --radius-sm: 8px;
            --shadow-lg: 0 16px 36px rgba(0, 0, 0, 0.35);
            --shadow-md: 0 12px 28px rgba(0, 0, 0, 0.3);
            --shadow-sm: 0 8px 18px rgba(0, 0, 0, 0.25);
        }

        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Prevent double-tap zoom */
            user-select: none;
            background: radial-gradient(120% 90% at 50% 0%, var(--theme-ambient), transparent 55%), var(--surface-0);
            color: var(--text-strong);
            --grid-size: 48px;
            --ambient-step: 0.8s;
            --ambient-duration: 20s;
        }

        body::before {
            content: "";
            position: fixed;
            inset: 0;
            background:
                linear-gradient(to right, rgba(148, 163, 184, 0.1) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(148, 163, 184, 0.1) 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
            opacity: 0.55;
            pointer-events: none;
            z-index: 0;
        }

        #ambient-paths {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;
        }

        .ambient-square {
            position: absolute;
            width: var(--grid-size);
            height: var(--grid-size);
            left: calc(var(--grid-size) * var(--x));
            top: calc(var(--grid-size) * var(--y));
            border-radius: var(--radius-sm);
            background: var(--theme-ambient);
            box-shadow: 0 0 0 var(--theme-shadow);
            opacity: 0;
            animation: ambient-glow var(--duration, var(--ambient-duration)) linear infinite;
            animation-delay: calc(var(--delay, 0s) + (var(--order) * var(--ambient-step)));
        }

        #app {
            position: relative;
            z-index: 1;
        }

        .panel-card {
            background: var(--surface-2);
            border: 1px solid var(--border-soft);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
        }

        .panel-inset {
            background: var(--surface-0);
            border: 1px solid var(--border-soft);
            border-radius: var(--radius-md);
        }

        .panel-divider {
            border-top: 1px solid var(--border-soft);
        }

        .eyebrow {
            font-size: 10px;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: var(--text-soft);
            font-weight: 600;
        }

        .title-core {
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: var(--text-strong);
        }

        .title-hero {
            font-size: clamp(2.4rem, 8vw, 3.6rem);
            font-weight: 900;
            letter-spacing: 0.18em;
            text-transform: uppercase;
        }

        .title-hero.is-defeat {
            color: #f87171;
            text-shadow: 0 0 18px rgba(248, 113, 113, 0.5);
        }

        .title-hero.is-victory {
            color: #4ade80;
            text-shadow: 0 0 18px rgba(74, 222, 128, 0.45);
        }

        .mark-hero {
            font-size: 1.25rem;
            font-weight: 600;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: var(--text-strong);
        }

        .mark-hero.is-victory {
            font-size: 3rem;
            letter-spacing: 0.1em;
        }

        .section-label {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 11px;
            letter-spacing: 0.32em;
            text-transform: uppercase;
            color: var(--text-muted);
            padding: 2px 2px 0;
            font-weight: 600;
        }

        .section-label::after {
            content: "";
            flex: 1;
            height: 1px;
            background: var(--border-soft);
        }

        .field-label {
            font-size: 11px;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: var(--text-soft);
            font-weight: 600;
        }

        .text-muted {
            color: var(--text-muted);
        }

        .text-soft {
            color: var(--text-soft);
        }

        .text-faint {
            color: var(--text-faint);
        }

        .input-field {
            background: var(--surface-1);
            border: 1px solid var(--border-soft);
            border-radius: var(--radius-md);
            color: var(--text-strong);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .input-field::placeholder {
            color: var(--text-faint);
        }

        .input-field:focus-visible {
            outline: none;
            border-color: var(--theme-color);
            box-shadow: 0 0 0 2px var(--theme-shadow-soft);
        }

        .input-field:focus {
            outline: none;
            border-color: var(--theme-color);
            box-shadow: 0 0 0 2px var(--theme-shadow-soft);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            border-radius: var(--radius-md);
            text-transform: uppercase;
            letter-spacing: 0.24em;
            font-weight: 600;
            font-size: 0.7rem;
            border: 1px solid transparent;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
        }

        .btn:focus-visible {
            outline: none;
            box-shadow: 0 0 0 2px var(--theme-shadow);
        }

        .btn-lg {
            font-size: 0.8rem;
            letter-spacing: 0.2em;
        }

        .btn-sm {
            font-size: 0.65rem;
            letter-spacing: 0.2em;
        }

        .btn-primary {
            background: var(--theme-color);
            color: #0b1220;
            box-shadow: 0 12px 24px var(--theme-shadow-soft);
            font-weight: 700;
        }

        .btn-primary:hover {
            filter: brightness(1.05);
        }

        .btn-secondary {
            background: var(--surface-3);
            border-color: var(--border-strong);
            color: var(--text-muted);
        }

        .btn-secondary:hover {
            background: var(--surface-hover);
            color: var(--text-strong);
        }

        .btn-ghost {
            background: transparent;
            border-color: var(--border-soft);
            color: var(--text-muted);
        }

        .btn-ghost:hover {
            background: rgba(255, 255, 255, 0.04);
            border-color: var(--border-strong);
            color: var(--text-strong);
        }

        .btn-danger {
            border-color: rgba(248, 113, 113, 0.4);
            color: #f87171;
        }

        .btn-danger:hover {
            border-color: rgba(248, 113, 113, 0.75);
            color: #fecaca;
        }

        .hud-panel {
            background: rgba(15, 23, 42, 0.92);
            border-bottom: 1px solid var(--border-soft);
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(8px);
        }

        .hud-title {
            font-size: 0.85rem;
            font-weight: 700;
            letter-spacing: 0.24em;
            text-transform: uppercase;
            color: var(--text-strong);
        }

        .hud-meta {
            font-size: 0.6rem;
            letter-spacing: 0.28em;
            text-transform: uppercase;
            color: var(--text-soft);
            font-weight: 600;
        }

        .hud-score {
            font-size: 1.6rem;
            font-weight: 800;
            color: #fbbf24;
            text-shadow: 0 0 16px rgba(251, 191, 36, 0.35);
            font-variant-numeric: tabular-nums;
        }

        .hud-subscore {
            font-size: 0.6rem;
            letter-spacing: 0.24em;
            text-transform: uppercase;
            color: var(--text-faint);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .status-chip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 2px 12px;
            border-radius: 999px;
            font-size: 10px;
            letter-spacing: 0.28em;
            text-transform: uppercase;
            border: 1px solid var(--border-soft);
            background: rgba(11, 18, 32, 0.7);
            color: var(--text-muted);
            font-weight: 600;
        }

        .status-chip[data-state="watch"],
        .status-chip[data-state="idle"] {
            border-color: var(--theme-color);
            color: var(--theme-color);
            box-shadow: 0 0 12px var(--theme-shadow-soft);
        }

        .status-chip[data-state="input"] {
            border-color: rgba(74, 222, 128, 0.5);
            color: #4ade80;
            box-shadow: 0 0 12px rgba(74, 222, 128, 0.35);
        }

        .status-chip[data-state="path"] {
            border-color: rgba(251, 191, 36, 0.6);
            color: #fbbf24;
            box-shadow: 0 0 12px rgba(251, 191, 36, 0.35);
        }

        .status-chip[data-state="retry"] {
            border-color: rgba(248, 113, 113, 0.6);
            color: #f87171;
            box-shadow: 0 0 12px rgba(248, 113, 113, 0.35);
        }

        .timer-track {
            background: var(--surface-3);
            border: 1px solid var(--border-strong);
            border-radius: 999px;
            overflow: hidden;
        }

        .timer-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, var(--theme-color), #60a5fa);
            box-shadow: 0 0 14px var(--theme-shadow-soft);
            transition: width 0.1s linear;
            border-radius: inherit;
        }

        .timer-fill[data-state="input"] {
            background: linear-gradient(90deg, #4ade80, #22c55e);
            box-shadow: 0 0 14px rgba(74, 222, 128, 0.4);
        }

        .timer-fill[data-state="danger"] {
            background: linear-gradient(90deg, #f87171, #ef4444);
            box-shadow: 0 0 14px rgba(248, 113, 113, 0.4);
        }

        .stat-accent {
            color: var(--theme-color);
            text-shadow: 0 0 12px var(--theme-shadow-soft);
        }

        .score-accent {
            color: #fbbf24;
            text-shadow: 0 0 12px rgba(251, 191, 36, 0.35);
            font-variant-numeric: tabular-nums;
        }

        .overlay-scrim {
            background: rgba(11, 18, 32, 0.92);
            border: 1px solid var(--border-soft);
            border-radius: var(--radius-lg);
            backdrop-filter: blur(6px);
        }

        .table-shell {
            background: var(--surface-1);
            border: 1px solid var(--border-soft);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            overflow: hidden;
        }

        .table-shell thead {
            background: var(--surface-3);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.32em;
            font-size: 11px;
            font-weight: 600;
        }

        .zone-card {
            background: var(--surface-2);
            border: 1px solid var(--border-soft);
            border-radius: var(--radius-md);
            transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .zone-card:hover {
            border-color: var(--zone-color, var(--theme-color));
            box-shadow: 0 0 0 1px var(--zone-color, var(--theme-color)), var(--shadow-sm);
            transform: translateY(-1px);
        }

        .zone-card:disabled,
        .zone-card.is-locked {
            cursor: not-allowed;
            opacity: 0.55;
            border-color: var(--border-soft);
            box-shadow: none;
            transform: none;
        }

        .zone-title {
            font-size: 1.2rem;
            font-weight: 700;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            color: var(--zone-color, var(--theme-color));
        }

        .zone-subtitle {
            font-size: 0.7rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        .zone-meta {
            font-size: 10px;
            letter-spacing: 0.32em;
            text-transform: uppercase;
            color: var(--text-faint);
        }

        .leaderboard-row {
            color: var(--text-muted);
            border-bottom: 1px solid var(--border-soft);
        }

        .leaderboard-row.is-highlight {
            color: #fbbf24;
            font-weight: 700;
            background: rgba(251, 191, 36, 0.12);
        }

        /* Custom Scrollbar for Leaderboard */
        .custom-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: var(--surface-3);
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: var(--border-strong);
            border-radius: 3px;
        }

        /* Grid Cell Animations */
        .cell {
            box-sizing: border-box;
            width: 100%;
            height: 100%;
            border-radius: var(--radius-sm);
            background-color: var(--surface-3);
            border: 1px solid var(--border-strong);
            cursor: pointer;
            touch-action: none;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
        }

        .grid-no-transitions .cell {
            transition: none !important;
        }

        @media (hover: none) {
            .cell:hover {
                background-color: var(--surface-3); /* Avoid sticky hover on touch */
            }
        }

        .cell:hover {
            background-color: var(--surface-hover);
        }

        .grid-locked {
            pointer-events: none;
        }
        
        .cell.active {
            background-color: var(--theme-color);
            box-shadow: 0 0 15px var(--theme-shadow);
            transform: scale(0.95);
            border-color: var(--theme-color);
        }

        .cell.success {
            background-color: #4ade80; /* Green 400 */
            box-shadow: 0 0 15px #4ade80;
            border-color: #4ade80;
        }

        .cell.correct {
            background-color: #4ade80; /* Green 400 */
            box-shadow: 0 0 15px #4ade80;
            border-color: #4ade80;
        }

        .cell.error {
            background-color: #f87171; /* Red 400 */
            box-shadow: 0 0 15px #f87171;
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
            border-color: #f87171;
        }

        .cell.reveal {
            background-color: #f59e0b; /* Amber 500 */
            box-shadow: 0 0 15px #f59e0b;
            border-color: #f59e0b;
        }

        .menu-title {
            font-size: clamp(2.5rem, 8vw, 4.75rem);
            font-weight: 800;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            background: linear-gradient(90deg, #38bdf8, #a855f7, #38bdf8);
            background-size: 200% auto;
            -webkit-background-clip: text;
            color: transparent;
            text-shadow: 0 0 18px var(--theme-shadow-soft);
            animation: title-glide 6s linear infinite;
        }

        .path-overlay {
            position: absolute;
            z-index: 5;
            pointer-events: none;
        }

        .path-line {
            stroke: #fbbf24;
            stroke-width: 6;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 0 6px rgba(245, 158, 11, 0.6));
        }

        .howto-card {
            background: var(--surface-2);
            border: 1px solid var(--border-strong);
            border-radius: var(--radius-lg);
            padding: 16px;
            box-shadow: var(--shadow-lg);
            animation: howto-rise 0.55s ease both;
        }

        .howto-step {
            font-size: 10px;
            letter-spacing: 0.28em;
            text-transform: uppercase;
            color: var(--text-soft);
            font-weight: 600;
        }

        .howto-section {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 11px;
            letter-spacing: 0.32em;
            text-transform: uppercase;
            color: var(--text-muted);
            padding: 2px 2px 0;
            font-weight: 600;
        }

        .howto-section::after {
            content: "";
            flex: 1;
            height: 1px;
            background: var(--border-soft);
        }

        .howto-visual {
            background: var(--surface-0);
            border: 1px solid var(--border-soft);
            border-radius: var(--radius-md);
            padding: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .howto-grid {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 6px;
            width: 140px;
            height: 140px;
        }

        .howto-cell {
            position: relative;
            border-radius: var(--radius-sm);
            background: var(--surface-3);
            border: 1px solid var(--border-strong);
            transition: background-color 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        }

        .howto-cell.is-watch {
            background: var(--theme-color);
            box-shadow: 0 0 12px var(--theme-shadow);
            border-color: var(--theme-color);
        }

        .howto-cell.is-repeat {
            background: #4ade80;
            box-shadow: 0 0 12px rgba(74, 222, 128, 0.65);
            border-color: #4ade80;
        }

        .step-badge {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.32em;
            text-transform: uppercase;
        }

        .step-badge.is-watch {
            color: var(--theme-color);
        }

        .step-badge.is-repeat {
            color: #4ade80;
        }

        .step-badge.is-survive {
            color: #fbbf24;
        }

        .howto-timer {
            width: 100%;
            height: 10px;
            background: var(--surface-3);
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid var(--border-strong);
        }

        .howto-timer span {
            display: block;
            height: 100%;
            width: 70%;
            background: linear-gradient(90deg, var(--theme-color), #60a5fa);
            animation: howto-sweep 2.8s ease-in-out infinite;
        }

        .howto-hearts {
            display: flex;
            gap: 6px;
        }

        .howto-heart {
            width: 20px;
            height: 20px;
        }

        .howto-heart.is-full {
            color: #f87171;
        }

        .howto-heart.is-empty {
            color: var(--text-faint);
        }

        .howto-score-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .howto-info-btn {
            width: 18px;
            height: 18px;
            border-radius: 999px;
            border: 1px solid var(--border-strong);
            background: var(--surface-1);
            color: var(--text-muted);
            font-size: 11px;
            font-weight: 600;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: border-color 0.2s ease, color 0.2s ease, background 0.2s ease;
        }

        .howto-info-btn:hover {
            border-color: var(--theme-color);
            color: var(--theme-color);
        }

        .howto-info-btn:focus-visible {
            outline: 2px solid var(--theme-shadow);
            outline-offset: 2px;
        }

        .howto-score-info {
            border-left: 2px solid var(--border-soft);
            margin: 4px 0 2px;
            padding-left: 8px;
            font-size: 11px;
            color: var(--text-muted);
            line-height: 1.5;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        @keyframes title-glide {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        @keyframes howto-rise {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes howto-sweep {
            0%, 100% { width: 92%; }
            50% { width: 35%; }
        }

        @keyframes heart-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }

        @keyframes ambient-glow {
            0% {
                opacity: 0;
                box-shadow: 0 0 0 var(--theme-shadow);
            }
            1.5% {
                opacity: 0.35;
                box-shadow: 0 0 18px var(--theme-shadow);
            }
            3% {
                opacity: 0.18;
                box-shadow: 0 0 10px var(--theme-shadow-soft);
            }
            4% {
                opacity: 0;
                box-shadow: 0 0 0 var(--theme-shadow);
            }
            100% {
                opacity: 0;
                box-shadow: 0 0 0 var(--theme-shadow);
            }
        }

        @media (prefers-reduced-motion: reduce) {
            .menu-title {
                animation: none;
            }

            .howto-card,
            .howto-timer span {
                animation: none;
            }

            .heart-icon.is-full {
                animation: none;
            }

            .ambient-square {
                animation: none;
                opacity: 0.12;
                box-shadow: 0 0 10px var(--theme-shadow-soft);
            }
        }

        .heart-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .heart-icon svg {
            width: 1em;
            height: 1em;
            display: block;
        }

        .heart-icon.is-full {
            color: #f87171;
            filter: drop-shadow(0 0 6px rgba(248, 113, 113, 0.45));
            animation: heart-pulse 2.4s ease-in-out infinite;
        }

        .heart-icon.is-empty {
            color: var(--text-faint);
            opacity: 0.7;
        }

        .theme-text {
            color: var(--theme-color);
            text-shadow: 0 0 12px var(--theme-shadow-soft);
        }

        .theme-bg {
            background-color: var(--theme-color);
            color: #0b1220;
            transition: filter 0.2s ease;
        }

        .theme-bg:hover {
            filter: brightness(1.08);
        }

        .theme-border {
            border-color: var(--theme-color);
        }

        .level-dot {
            width: 0.65em;
            height: 0.65em;
            border-radius: 999px;
            transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease, opacity 0.3s ease;
        }

        .level-dot.complete {
            background-color: var(--theme-color);
            opacity: 0.35;
        }

        .stage-level-dot {
            opacity: 1;
        }

        .level-dot.current {
            background-color: var(--theme-color);
            box-shadow: 0 0 10px var(--theme-shadow);
            transform: scale(1);
        }

        .level-dot.upcoming {
            background-color: transparent;
            border: 1px solid var(--border-strong);
        }

        .auto-advance-btn {
            position: relative;
            overflow: hidden;
        }

        .auto-advance-btn .btn-progress {
            position: absolute;
            inset: 0;
            background: rgba(11, 18, 32, 0.45);
            transform: scaleX(0);
            transform-origin: left;
            border-radius: inherit;
        }

        .auto-advance-btn.is-counting .btn-progress {
            animation: btn-fill var(--progress-duration, 5000ms) linear forwards;
        }

        @keyframes btn-fill {
            from { transform: scaleX(0); }
            to { transform: scaleX(1); }
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">
    <div id="ambient-paths" aria-hidden="true"></div>

    <!-- Game Container -->
    <div id="app" class="flex-1 flex flex-col relative max-w-lg mx-auto w-full h-full">
        
        <!-- HEADER / HUD -->
        <header id="hud-header" class="hud-panel p-4 z-10 hidden">
            <div class="flex justify-between items-center mb-2">
                <div>
                    <h1 class="hud-title">REMEMBER THE PATH</h1>
                    <div id="stage-info" class="hud-meta font-mono hidden">ZONE 1 - STAGE 1</div>
                </div>
                <div class="text-right">
                    <div id="score-display" class="hud-score hidden">0</div>
                </div>
            </div>
            
            <!-- Hearts & Timer HUD -->
            <div id="game-hud" class="hidden flex flex-col gap-2">
                <div class="flex justify-between items-center">
                    <div id="hearts-container" class="flex gap-1">
                        <!-- Hearts injected here -->
                    </div>
                    <div id="level-breadcrumbs" class="flex gap-1.5 items-center"></div>
                </div>
                <!-- Timer Bar -->
                <div class="w-full h-5 timer-track">
                    <div id="timer-bar" class="timer-fill" data-state="watch"></div>
                </div>
            </div>
        </header>

        <!-- MAIN CONTENT AREA -->
        <main class="flex-1 relative flex items-center justify-center p-4">
            
            <!-- MENU SCREEN -->
            <div id="menu-screen" class="absolute inset-0 z-20 flex flex-col items-center justify-center p-6 space-y-6">
                <div class="text-center space-y-3">
                    <h1 id="menu-title" class="menu-title">REMEMBER THE PATH</h1>
                </div>
                
                <div class="w-full max-w-xs panel-card p-4 space-y-4">
                    <div>
                        <label class="field-label block mb-1">Player Name</label>
                        <input type="text" id="player-name" class="input-field w-full p-3" placeholder="Enter name" maxlength="10">
                    </div>
                    <button id="btn-start" class="w-full btn btn-primary btn-lg py-3 px-4 active:scale-95">START GAME</button>
                    <button id="btn-howto" class="w-full btn btn-secondary btn-lg py-3 px-4 active:scale-95">HOW TO PLAY</button>
                    <button id="btn-leaderboard" class="w-full btn btn-ghost btn-lg py-3 px-4 active:scale-95">LEADERBOARD</button>
                </div>
            </div>

            <!-- ZONE SELECT SCREEN -->
            <div id="zone-screen" class="hidden absolute inset-0 z-20 flex flex-col items-center justify-center p-6 space-y-6">
                <div id="zone-list" class="w-full max-w-md space-y-3"></div>
                <button id="btn-zone-back" class="w-full max-w-xs btn btn-secondary btn-lg py-3 px-4 active:scale-95">Back</button>
            </div>

            <!-- STAGE INTRO SCREEN -->
            <div id="stage-screen" class="hidden absolute inset-0 z-20 flex flex-col items-center justify-center p-6 space-y-6">
                <div class="text-center space-y-2">
                    <div id="zone-title" class="eyebrow">ZONE 1</div>
                    <div class="flex items-baseline justify-center gap-2">
                        <h2 id="stage-title" class="text-4xl font-extrabold title-core">STAGE 1</h2>
                        <span id="stage-count" class="text-xs uppercase tracking-[0.32em] text-muted">of 1</span>
                    </div>
                </div>
                <div class="w-full max-w-xs panel-card p-4 text-center">
                    <div class="field-label mb-1">Difficulty</div>
                    <div id="stage-difficulty" class="text-2xl font-bold stat-accent">Piece of Cake</div>
                    <div class="mt-4 w-24 mx-auto panel-divider"></div>
                    <div class="mt-3">
                        <div class="field-label mb-2">Levels</div>
                        <div id="stage-level-dots" class="flex gap-2.5 justify-center"></div>
                    </div>
                </div>
                <button id="btn-stage-start" class="w-full max-w-xs btn btn-primary btn-lg py-3 px-4 active:scale-95">START STAGE</button>
            </div>

            <!-- GRID CONTAINER -->
            <div id="game-container" class="hidden relative flex items-center justify-center w-full aspect-square max-w-[400px] panel-card p-2">
                <div id="grid" class="w-full h-full grid gap-1.5 sm:gap-2">
                    <!-- Grid cells generated by JS -->
                </div>

                <!-- Path reveal overlay -->
                <svg id="path-overlay" class="path-overlay hidden">
                    <defs>
                        <marker id="path-arrow" markerWidth="5" markerHeight="5" refX="4" refY="2.5" orient="auto">
                            <path d="M 0 0 L 5 2.5 L 0 5 z" fill="#fbbf24"></path>
                        </marker>
                    </defs>
                    <path id="path-line" class="path-line" marker-end="url(#path-arrow)"></path>
                </svg>
                
                <!-- Overlay for "Level Complete" / "Get Ready" -->
                <div id="overlay-message" class="absolute inset-0 z-10 overlay-scrim flex flex-col items-center justify-center text-center hidden">
                    <h3 id="overlay-title" class="text-2xl font-bold title-core mb-2">LEVEL COMPLETE</h3>
                    <div id="overlay-breakdown" class="w-full max-w-xs panel-card p-4 mb-5 text-left">
                        <div class="flex justify-between text-[11px] uppercase tracking-[0.32em] text-muted mb-2">
                            <span>Score Breakdown</span>
                            <span>Value</span>
                        </div>
                        <div class="space-y-1 text-sm">
                            <div class="flex justify-between">
                                <span class="text-muted">Level Cleared</span>
                                <span id="overlay-score-base" class="font-mono score-accent">+0</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-muted">Time Bonus</span>
                                <span id="overlay-score-time" class="font-mono score-accent">+0</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-muted">Stage Multiplier</span>
                                <span id="overlay-score-stage" class="font-mono score-accent">x1</span>
                            </div>
                        </div>
                        <div class="mt-2 pt-2 panel-divider flex justify-between text-sm font-semibold">
                            <span>Total</span>
                            <span id="overlay-score-total" class="font-mono score-accent">+0</span>
                        </div>
                    </div>
                    <button id="btn-next-level" class="auto-advance-btn btn btn-primary btn-lg py-2 px-6 active:scale-95 hidden">
                        <span class="relative z-10">CONTINUE</span>
                        <span class="btn-progress" aria-hidden="true"></span>
                    </button>
                </div>
            </div>

            <!-- LEADERBOARD SCREEN -->
            <div id="leaderboard-screen" class="hidden absolute inset-0 z-30 flex flex-col p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold title-core">Leaderboard</h2>
                    <button id="btn-close-leaderboard" class="btn btn-secondary btn-sm py-2 px-3">Close</button>
                </div>
                <div class="flex-1 overflow-y-auto custom-scroll table-shell">
                    <table class="w-full text-left border-collapse">
                        <thead class="sticky top-0">
                            <tr>
                                <th class="p-3">Rank</th>
                                <th class="p-3">Player</th>
                                <th class="p-3 text-right">Zone 1</th>
                                <th class="p-3 text-right">Zone 2</th>
                                <th class="p-3 text-right">Zone 3</th>
                                <th class="p-3 text-right">Total Score</th>
                            </tr>
                        </thead>
                        <tbody id="leaderboard-body" class="text-sm">
                            <!-- Rows injected here -->
                        </tbody>
                    </table>
                </div>
                <div class="mt-4 text-center">
                    <button id="btn-reset-data" class="btn btn-ghost btn-danger btn-sm py-2 px-3">Clear Data</button>
                </div>
            </div>

            <!-- HOW TO PLAY SCREEN -->
            <div id="howto-screen" class="hidden absolute inset-0 z-30 flex flex-col p-6">
                <div class="flex items-start justify-between gap-4 mb-5">
                    <div>
                        <h2 class="text-3xl font-extrabold title-core mt-1">How To Play</h2>
                        <p class="text-sm text-muted mt-1 max-w-sm">Watch the pattern, tap it back, and outrun the timer.</p>
                    </div>
                    <button id="btn-close-howto" class="btn btn-secondary btn-sm py-2 px-3">Back</button>
                </div>
                <div class="flex-1 overflow-y-auto custom-scroll pr-2">
                    <div class="space-y-4 max-w-md mx-auto">
                        <div class="howto-section">Steps</div>
                        <div class="howto-card" style="animation-delay: 0.05s;">
                            <div class="flex items-center justify-between mb-3">
                                <div class="howto-step">Step 1</div>
                                <div class="step-badge is-watch">Watch</div>
                            </div>
                            <div class="flex flex-col sm:flex-row gap-4 items-center">
                                <div class="howto-visual">
                                    <div class="howto-grid" data-howto="watch">
                                        <div class="howto-cell" data-watch-step="1"></div>
                                        <div class="howto-cell" data-watch-step="2"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell" data-watch-step="3"></div>
                                        <div class="howto-cell" data-watch-step="4"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell" data-watch-step="5"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell" data-watch-step="6"></div>
                                        <div class="howto-cell" data-watch-step="7"></div>
                                    </div>
                                </div>
                                <p class="text-sm text-muted leading-relaxed">The path flashes once. Memorize it and get ready to repeat it.</p>
                            </div>
                        </div>
                        <div class="howto-card" style="animation-delay: 0.12s;">
                            <div class="flex items-center justify-between mb-3">
                                <div class="howto-step">Step 2</div>
                                <div class="step-badge is-repeat">Repeat</div>
                            </div>
                            <div class="flex flex-col sm:flex-row gap-4 items-center">
                                <div class="howto-visual">
                                    <div class="howto-grid" data-howto="repeat">
                                        <div class="howto-cell" data-repeat-step="1"></div>
                                        <div class="howto-cell" data-repeat-step="2"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell" data-repeat-step="3"></div>
                                        <div class="howto-cell" data-repeat-step="4"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell" data-repeat-step="5"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell" data-repeat-step="6"></div>
                                        <div class="howto-cell" data-repeat-step="7"></div>
                                    </div>
                                </div>
                                <p class="text-sm text-muted leading-relaxed">Tap the same squares in order. A wrong tap costs a heart.</p>
                            </div>
                        </div>
                        <div class="howto-card" style="animation-delay: 0.19s;">
                            <div class="flex items-center justify-between mb-3">
                                <div class="howto-step">Step 3</div>
                                <div class="step-badge is-survive">Survive</div>
                            </div>
                            <div class="flex flex-col sm:flex-row gap-4 items-center">
                                <div class="howto-visual w-full">
                                    <div class="w-full space-y-3">
                                        <div class="howto-timer"><span></span></div>
                                        <div class="flex items-center justify-between text-[11px] uppercase tracking-[0.32em] text-muted">
                                            <span>Time</span>
                                            <span>Hearts</span>
                                        </div>
                                        <div class="flex items-center justify-between">
                                            <div class="flex-1"></div>
                                            <div class="howto-hearts">
                                                <svg class="howto-heart is-full" viewBox="0 0 24 24" aria-hidden="true">
                                                    <path fill="currentColor" d="M12 21s-6.713-4.477-9.6-8.23C.46 10.357.999 7.07 3.044 5.25 4.94 3.57 7.62 3.78 9.272 5.49L12 8.323l2.728-2.834c1.652-1.71 4.333-1.92 6.229-.24 2.045 1.82 2.584 5.107.644 7.52C18.713 16.523 12 21 12 21z"></path>
                                                </svg>
                                                <svg class="howto-heart is-full" viewBox="0 0 24 24" aria-hidden="true">
                                                    <path fill="currentColor" d="M12 21s-6.713-4.477-9.6-8.23C.46 10.357.999 7.07 3.044 5.25 4.94 3.57 7.62 3.78 9.272 5.49L12 8.323l2.728-2.834c1.652-1.71 4.333-1.92 6.229-.24 2.045 1.82 2.584 5.107.644 7.52C18.713 16.523 12 21 12 21z"></path>
                                                </svg>
                                                <svg class="howto-heart is-empty" viewBox="0 0 24 24" aria-hidden="true">
                                                    <path fill="currentColor" d="M12 21s-6.713-4.477-9.6-8.23C.46 10.357.999 7.07 3.044 5.25 4.94 3.57 7.62 3.78 9.272 5.49L12 8.323l2.728-2.834c1.652-1.71 4.333-1.92 6.229-.24 2.045 1.82 2.584 5.107.644 7.52C18.713 16.523 12 21 12 21z"></path>
                                                </svg>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <p class="text-sm text-muted leading-relaxed">Beat the timer before it drains. Running out of hearts ends the run.</p>
                            </div>
                        </div>
                        <div class="howto-section">Scoring</div>
                        <div class="howto-card" style="animation-delay: 0.26s;">
                            <div class="flex items-center justify-between mb-3">
                                <div class="text-xs text-muted font-semibold uppercase tracking-[0.32em]">Score Breakdown Per Level</div>
                                <div class="text-xs score-accent font-semibold uppercase tracking-[0.32em]">Value</div>
                            </div>
                            <div class="space-y-2 text-sm text-muted">
                                <div class="howto-score-row">
                                    <div class="flex items-center gap-2">
                                        <span>Completing a Level</span>
                                        <button class="howto-info-btn" type="button" aria-label="Explain points per level" aria-expanded="false" aria-controls="howto-score-info-base" data-score-info>?</button>
                                    </div>
                                    <span id="howto-score-base" class="font-mono score-accent">+0</span>
                                </div>
                                <div id="howto-score-info-base" class="howto-score-info hidden">Flat points for clearing a level, before any bonuses.</div>
                                <div class="howto-score-row">
                                    <div class="flex items-center gap-2">
                                        <span>Time Bonus</span>
                                        <button class="howto-info-btn" type="button" aria-label="Explain time bonus" aria-expanded="false" aria-controls="howto-score-info-time" data-score-info>?</button>
                                    </div>
                                    <span id="howto-score-time" class="font-mono score-accent">+0 ~ +0</span>
                                </div>
                                <div id="howto-score-info-time" class="howto-score-info hidden">Finish faster to push the time bonus toward the max.</div>
                                <div class="howto-score-row">
                                    <div class="flex items-center gap-2">
                                    <span>Stage Multiplier</span>
                                        <button class="howto-info-btn" type="button" aria-label="Explain stage multiplier" aria-expanded="false" aria-controls="howto-score-info-stage" data-score-info>?</button>
                                    </div>
                                    <span id="howto-score-stage" class="font-mono score-accent">x stage number</span>
                                </div>
                                <div id="howto-score-info-stage" class="howto-score-info hidden">Faster performance in later stages are rewarded more.</div>
                            </div>
                            <div id="howto-score-formula" class="mt-3 text-xs text-muted"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- GAME OVER SCREEN -->
            <div id="game-over-screen" class="hidden absolute inset-0 z-30 flex flex-col items-center justify-center p-6 text-center">
                <h2 id="game-over-title" class="title-hero is-defeat mb-2">GAME OVER</h2>
                <div id="game-over-mark" class="mark-hero mb-2">Good try!</div>
                <p id="game-over-description" class="text-muted mb-6">You ran out of hearts.</p>
                
                <div class="panel-card p-6 w-full max-w-xs mb-6">
                    <div class="field-label mb-1">Final Score</div>
                    <div id="final-score" class="text-4xl font-bold font-mono score-accent">0</div>
                </div>

                <div class="space-y-3 w-full max-w-xs">
                    <button id="btn-retry" class="w-full btn btn-primary btn-lg py-3 px-4 active:scale-95">TRY AGAIN</button>
                    <button id="btn-home" class="w-full btn btn-ghost btn-lg py-3 px-4 active:scale-95">BACK TO ZONES</button>
                </div>
            </div>

        </main>

        <div id="app-version" class="absolute bottom-2 right-3 text-[10px] text-faint uppercase tracking-widest pointer-events-none"></div>
    </div>

    <!-- AUDIO ELEMENTS (Simple synthesizers used in JS, fallback placeholders here) -->

    <script>
        /**
         * CONFIGURATION
         */
        const APP_VERSION = 'v1.2.0';

        const BASE_STAGES = [
            { id: 1, size: 3, levels: 1 },
            { id: 2, size: 4, levels: 2 },
            { id: 3, size: 5, levels: 3 },
            { id: 4, size: 6, levels: 4 },
            { id: 5, size: 7, levels: 5 },
        ];

        const CONFIG = {
            zones: [
                {
                    id: 1,
                    title: 'Axis Flow',
                    description: 'Straight-edge circuits carved in electric blue.',
                    theme: { color: '#38bdf8', name: 'Zone 1' },
                    pathStyle: 'orthogonal',
                    stages: BASE_STAGES.map(stage => ({ ...stage }))
                },
                {
                    id: 2,
                    title: 'Vector Rush',
                    description: 'Angled flashes slicing through the neon haze.',
                    theme: { color: '#a855f7', name: 'Zone 2' },
                    pathStyle: 'diagonal',
                    stages: BASE_STAGES.map(stage => ({ ...stage }))
                },
                {
                    id: 3,
                    title: 'Fractured Drift',
                    description: 'Fragments drifting away from the matrix.',
                    theme: { color: '#ec4899', name: 'Zone 3' },
                    pathStyle: 'broken-diagonal',
                    stages: BASE_STAGES.map(stage => ({ ...stage }))
                },
                {
                    id: 4,
                    title: 'Quantum Oscillation (Coming Soon)',
                    description: 'Both here and not here.',
                    theme: { color: '#22d3ee', name: 'Zone 4' },
                    pathStyle: 'orthogonal',
                    stages: BASE_STAGES.map(stage => ({ ...stage })),
                    comingSoon: true
                }
            ],
            initialHearts: 3,
            baseScorePerLevel: 10,
            scoring: {
                timeBonusMultiplier: 5
            },
            playback: {
                speedBaseMs: 300, // ms per square
                speedMinMs: 75,  // Cap for speed
                speedDecrementPerStageMs: 50, // ms decrease per stage
                startDelayMs: 800, // Delay before playback starts
                gapRatio: 0.5, // Gap between tones as ratio of tone duration
                toneBaseHz: 300, // Starting tone frequency
                toneStepHz: 50, // Frequency increase per square
                toneDurationSec: 0.1 // Tone duration in seconds
            },
            input: {
                timePerSquareBaseSec: 1.5, // Seconds per square for input
                timePerSquareMinSec: 0.5,  // Cap for time per square
                timePerSquareStagePenaltySec: 0.4, // Seconds reduced per stage
                tickRateMs: 50,
                lowTimeThresholdPct: 30,
                successClearMs: 200,
                errorClearMs: 400,
                retryDelayMs: 300,
                correctToneBaseHz: 400,
                correctToneStepHz: 50,
                correctToneDurationSec: 0.1,
                wrongToneHz: 150,
                wrongToneDurationSec: 0.3,
                timeUpToneHz: 100,
                timeUpToneDurationSec: 0.5
            },
            reveal: {
                mistakeMs: 2500
            },
            levelTransition: {
                breakdownMs: 2000,
                breakdownAutoAdvanceMs: 5000,
                levelIntroMs: 2000
            },
            path: {
                minTurnsAtLevelZero: 0, // Initial min turns
                minTurnsPerLevelOffset: 1, // Increases min turns as levels progress
                lengthBase: 4, // Base path length
                lengthSizeDivisor: 2, // Larger grids yield longer paths
                attemptLimit: 50, // Max attempts to generate a valid path
                fallbackMinLength: 3, // Fallback path length if no valid path found
                fallbackMaxLength: 4, // Fallback path length if no valid path found
                fallbackRow: 0, // Fallback row to start from if no valid path found
                broken: {
                    minSegments: 2,
                    maxSegments: 4,
                    segmentMinLength: 2,
                    segmentMaxLength: 4,
                    minGapDistance: 2,
                    segmentPauseMs: 240
                }
            },
            audio: {
                gainStart: 0.1,
                gainEnd: 0.01,
                successToneFreqsHz: [800, 1200],
                successToneDelayMs: 100,
                successToneDurationSec: 0.1,
                stageIntroToneType: 'sine',
                stageIntroToneFreqsHz: [420, 520],
                stageIntroToneDelayMs: 140,
                stageIntroToneDurationSec: 0.12,
                gameOverToneType: 'sawtooth',
                gameOverToneFreqsHz: [200, 140],
                gameOverToneDelayMs: 120,
                gameOverToneDurationSec: 0.25,
                victoryToneType: 'triangle',
                victoryToneFreqsHz: [523, 659, 784],
                victoryToneDelayMs: 120,
                victoryToneDurationSec: 0.15
            },
            ui: {
                heartFontSizeRem: 1.25
            },
            leaderboard: {
                maxEntries: 50,
                highlightTopCount: 3,
                topRankIcons: ['', '', '']
            },
            timing: {
                msPerSecond: 1000
            },
            stageDifficulty: [
                'Very Easy',
                'Easy',
                'Normal',
                'Medium',
                'Hard',
                'Impossible!',
            ],
            gameOverMessages: [
                'Good try!',
                'So close!',
                'Nice effort!',
                'Not bad!',
                'That was good!'
            ],
            localStorageKey: 'ftp_leaderboard_v1'
        };

        /**
         * STATE MANAGEMENT
         */
        const state = {
            status: 'MENU', // MENU, WATCH, INPUT, SUCCESS, FAIL, GAMEOVER
            player: {
                name: 'Player',
                score: 0,
                hearts: CONFIG.initialHearts,
                zoneIndex: 0,
                stageIndex: 0,
                levelIndex: 0 // 0-based, so 0 is Level 1
            },
            grid: [],
            path: [], // Array of {r, c}
            pathSegments: [],
            inputIndex: 0,
            timer: null,
            timerValue: 0,
            maxTime: 0
        };

        const howtoTimers = {
            watch: null,
            repeat: null
        };

        const levelTransitionTimers = {
            breakdownAuto: null,
            levelIntro: null,
            advanceTriggered: false,
            breakdownAdvance: null
        };

        // DOM Elements
        const screens = {
            menu: document.getElementById('menu-screen'),
            zones: document.getElementById('zone-screen'),
            stage: document.getElementById('stage-screen'),
            game: document.getElementById('game-container'),
            leaderboard: document.getElementById('leaderboard-screen'),
            howto: document.getElementById('howto-screen'),
            gameOver: document.getElementById('game-over-screen')
        };
        
        const ui = {
            header: document.getElementById('hud-header'),
            hud: document.getElementById('game-hud'),
            stageInfo: document.getElementById('stage-info'),
            scoreDisplay: document.getElementById('score-display'),
            levelBreadcrumbs: document.getElementById('level-breadcrumbs'),
            heartsContainer: document.getElementById('hearts-container'),
            statusText: document.getElementById('status-text'),
            timerBar: document.getElementById('timer-bar'),
            grid: document.getElementById('grid'),
            overlay: document.getElementById('overlay-message'),
            overlayTitle: document.getElementById('overlay-title'),
            overlayBreakdown: document.getElementById('overlay-breakdown'),
            overlaySubtitle: document.getElementById('overlay-subtitle'),
            overlayBaseScore: document.getElementById('overlay-score-base'),
            overlayTimeBonus: document.getElementById('overlay-score-time'),
            overlayStageBonus: document.getElementById('overlay-score-stage'),
            overlayTotalScore: document.getElementById('overlay-score-total'),
            btnNext: document.getElementById('btn-next-level'),
            pathOverlay: document.getElementById('path-overlay'),
            pathLine: document.getElementById('path-line'),
            zoneTitle: document.getElementById('zone-title'),
            stageTitle: document.getElementById('stage-title'),
            stageCount: document.getElementById('stage-count'),
            stageLevelDots: document.getElementById('stage-level-dots'),
            stageDifficulty: document.getElementById('stage-difficulty'),
            playerNameInput: document.getElementById('player-name'),
            zoneList: document.getElementById('zone-list'),
            finalScore: document.getElementById('final-score'),
            leaderboardBody: document.getElementById('leaderboard-body'),
            gameOverTitle: document.getElementById('game-over-title'),
            gameOverMark: document.getElementById('game-over-mark'),
            gameOverDescription: document.getElementById('game-over-description')
        };
        const GAME_OVER_TITLE_CLASS = 'title-hero is-defeat mb-2';
        const VICTORY_TITLE_CLASS = 'title-hero is-victory mb-2';
        const GAME_OVER_MARK_CLASS = 'mark-hero mb-2';
        const VICTORY_MARK_CLASS = 'mark-hero is-victory mb-2';

        /**
         * PATH GENERATION ALGORITHM
         */
        const ORTHO_DIRECTIONS = [
            { dr: -1, dc: 0 },
            { dr: 1, dc: 0 },
            { dr: 0, dc: -1 },
            { dr: 0, dc: 1 }
        ];

        const DIAGONAL_DIRECTIONS = [
            ...ORTHO_DIRECTIONS,
            { dr: -1, dc: -1 },
            { dr: -1, dc: 1 },
            { dr: 1, dc: -1 },
            { dr: 1, dc: 1 }
        ];

        function gridKey(r, c) {
            return `${r},${c}`;
        }

        const PathGenerator = {
            generate({ size, levelIndex, zone }) {
                const minTurns = levelIndex === 0
                    ? CONFIG.path.minTurnsAtLevelZero
                    : levelIndex + CONFIG.path.minTurnsPerLevelOffset;
                const targetLength = Math.min(
                    size * size,
                    CONFIG.path.lengthBase + levelIndex + Math.floor(size / CONFIG.path.lengthSizeDivisor)
                );

                const pathStyle = zone?.pathStyle || 'orthogonal';

                if (pathStyle === 'broken-diagonal') {
                    return this.generateBrokenPath({ size, targetLength, minTurns });
                }

                const allowDiagonal = pathStyle === 'diagonal';
                const path = this.generateContinuousPath({
                    size,
                    targetLength,
                    minTurns,
                    allowDiagonal
                });
                const finalPath = this.ensureFallbackPath(path, size);

                return {
                    path: finalPath,
                    segments: finalPath.map(() => 0)
                };
            },

            generateContinuousPath({ size, targetLength, minTurns, allowDiagonal, blocked, startConstraint }) {
                const blockedSet = blocked || new Set();
                let bestPath = [];

                for (let attempt = 0; attempt < CONFIG.path.attemptLimit; attempt++) {
                    const start = this.pickStartCell(size, blockedSet, startConstraint);
                    if (!start) break;

                    const path = this.recursiveWalk(
                        size,
                        start.r,
                        start.c,
                        [],
                        null,
                        0,
                        targetLength,
                        minTurns,
                        allowDiagonal,
                        blockedSet
                    );

                    if (path && path.length >= targetLength) {
                        return path;
                    }
                    if (path && path.length > bestPath.length) bestPath = path;
                }

                return bestPath;
            },

            generateBrokenPath({ size, targetLength, minTurns }) {
                const broken = CONFIG.path.broken;
                const allowDiagonal = true;
                const segmentCount = this.pickSegmentCount(targetLength, broken);
                const segmentLengths = this.buildSegmentLengths(
                    targetLength,
                    segmentCount,
                    broken.segmentMinLength,
                    broken.segmentMaxLength
                );
                const segmentTurns = this.buildSegmentTurns(minTurns, segmentLengths);

                const used = new Set();
                const path = [];
                const segments = [];
                let prevEnd = null;

                for (let i = 0; i < segmentLengths.length; i++) {
                    const segLength = segmentLengths[i];
                    if (segLength <= 0) continue;

                    const startConstraint = (r, c) => {
                        if (!prevEnd) return true;
                        return this.isGapDistanceOk(prevEnd, { r, c }, broken.minGapDistance);
                    };

                    let segmentPath = this.generateContinuousPath({
                        size,
                        targetLength: segLength,
                        minTurns: segmentTurns[i],
                        allowDiagonal,
                        blocked: used,
                        startConstraint
                    });

                    if (segmentPath.length < segLength) {
                        segmentPath = this.generateContinuousPath({
                            size,
                            targetLength: segLength,
                            minTurns: 0,
                            allowDiagonal,
                            blocked: used,
                            startConstraint
                        });
                    }

                    if (segmentPath.length < segLength) {
                        segmentPath = this.generateContinuousPath({
                            size,
                            targetLength: segLength,
                            minTurns: 0,
                            allowDiagonal,
                            blocked: used
                        });
                    }

                    if (!segmentPath.length) break;

                    segmentPath.forEach((step) => {
                        path.push(step);
                        segments.push(i);
                        used.add(gridKey(step.r, step.c));
                    });
                    prevEnd = segmentPath[segmentPath.length - 1];
                }

                const finalPath = this.ensureFallbackPath(path, size);
                const finalSegments = finalPath.length === path.length
                    ? segments
                    : finalPath.map(() => 0);

                return {
                    path: finalPath,
                    segments: finalSegments
                };
            },

            pickSegmentCount(targetLength, broken) {
                const minSegments = Math.max(
                    broken.minSegments,
                    Math.ceil(targetLength / broken.segmentMaxLength)
                );
                const maxSegments = Math.min(
                    broken.maxSegments,
                    Math.floor(targetLength / broken.segmentMinLength)
                );

                if (minSegments <= maxSegments) {
                    return getRandomInt(minSegments, maxSegments);
                }

                const fallback = Math.max(1, Math.floor(targetLength / broken.segmentMinLength));
                return Math.min(broken.minSegments, fallback) || 1;
            },

            buildSegmentLengths(targetLength, segments, minLen, maxLen) {
                if (segments <= 1) return [targetLength];

                const lengths = [];
                let remaining = targetLength;

                for (let i = 0; i < segments; i++) {
                    const segmentsLeft = segments - i;
                    const minRemaining = (segmentsLeft - 1) * minLen;
                    const maxForThis = Math.min(maxLen, remaining - minRemaining);
                    const length = (i === segments - 1)
                        ? remaining
                        : getRandomInt(minLen, maxForThis);
                    lengths.push(length);
                    remaining -= length;
                }

                return lengths;
            },

            buildSegmentTurns(totalTurns, segmentLengths) {
                const segments = segmentLengths.length;
                if (segments === 0) return [];

                const base = Math.floor(totalTurns / segments);
                const remainder = totalTurns % segments;

                return segmentLengths.map((length, index) => {
                    const maxTurns = Math.max(0, length - 1);
                    const desired = base + (index < remainder ? 1 : 0);
                    return Math.min(maxTurns, desired);
                });
            },

            ensureFallbackPath(path, size) {
                if (path.length >= CONFIG.path.fallbackMinLength) {
                    return path;
                }

                const fallbackLength = Math.min(size, CONFIG.path.fallbackMaxLength);
                const fallback = [];
                for (let i = 0; i < fallbackLength; i++) {
                    fallback.push({ r: CONFIG.path.fallbackRow, c: i });
                }
                return fallback;
            },

            pickStartCell(size, blockedSet, constraint) {
                const maxAttempts = 30;

                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    const r = Math.floor(Math.random() * size);
                    const c = Math.floor(Math.random() * size);
                    if (blockedSet.has(gridKey(r, c))) continue;
                    if (typeof constraint === 'function' && !constraint(r, c)) continue;
                    return { r, c };
                }

                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (blockedSet.has(gridKey(r, c))) continue;
                        if (typeof constraint === 'function' && !constraint(r, c)) continue;
                        return { r, c };
                    }
                }

                return null;
            },

            isGapDistanceOk(prev, next, minDistance) {
                if (!prev || !next) return true;
                const dr = Math.abs(prev.r - next.r);
                const dc = Math.abs(prev.c - next.c);
                return Math.max(dr, dc) >= minDistance;
            },

            recursiveWalk(
                size,
                r,
                c,
                currentPath,
                lastDir,
                currentTurns,
                targetLen,
                minTurns,
                allowDiagonal,
                blockedSet
            ) {
                const newPath = [...currentPath, { r, c }];

                if (newPath.length === targetLen) {
                    return (currentTurns >= minTurns) ? newPath : null;
                }

                const directions = allowDiagonal
                    ? [...DIAGONAL_DIRECTIONS]
                    : [...ORTHO_DIRECTIONS];

                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }

                for (let dir of directions) {
                    const nr = r + dir.dr;
                    const nc = c + dir.dc;

                    if (nr >= 0 && nr < size && nc >= 0 && nc < size) {
                        if (blockedSet && blockedSet.has(gridKey(nr, nc))) continue;
                        if (!newPath.some(p => p.r === nr && p.c === nc)) {
                            let newTurns = currentTurns;
                            if (lastDir && (lastDir.dr !== dir.dr || lastDir.dc !== dir.dc)) {
                                newTurns++;
                            }

                            const result = this.recursiveWalk(
                                size,
                                nr,
                                nc,
                                newPath,
                                dir,
                                newTurns,
                                targetLen,
                                minTurns,
                                allowDiagonal,
                                blockedSet
                            );
                            if (result) return result;
                        }
                    }
                }
                return null;
            }
        };

        /**
         * AMBIENT PATHS
         */
        const AMBIENT_PATHS = {
            minPaths: 3,
            maxPaths: 6,
            minLength: 10,
            maxLength: 22,
            minStartDistance: 4,
            pauseSec: 2.4
        };

        let ambientResizeTimer = null;
        let ambientRefreshTimer = null;

        function setupAmbientPaths() {
            const container = document.getElementById('ambient-paths');
            if (!container) return;

            const style = getComputedStyle(document.body);
            const gridSize = parseFloat(style.getPropertyValue('--grid-size')) || 48;
            const stepSec = parseCssTime(style.getPropertyValue('--ambient-step'), 0.8);
            const baseDuration = parseCssTime(style.getPropertyValue('--ambient-duration'), 20);

            const cols = Math.max(8, Math.floor(window.innerWidth / gridSize));
            const rows = Math.max(10, Math.floor(window.innerHeight / gridSize));
            const area = cols * rows;
            const pathCount = clamp(Math.round(area / 60), AMBIENT_PATHS.minPaths, AMBIENT_PATHS.maxPaths);

            container.innerHTML = '';

            let maxDuration = 0;
            let maxDelay = 0;
            const starts = [];
            for (let i = 0; i < pathCount; i++) {
                starts.push(pickAmbientStart(cols, rows, starts, AMBIENT_PATHS.minStartDistance));
            }

            starts.forEach(start => {
                const length = clamp(
                    getRandomInt(AMBIENT_PATHS.minLength, AMBIENT_PATHS.maxLength),
                    6,
                    cols * rows
                );
                const step = stepSec * (0.8 + Math.random() * 0.45);
                const duration = Math.max(baseDuration, (length * step) + AMBIENT_PATHS.pauseSec);
                const delay = Math.random() * 3;
                const path = buildAmbientPath(cols, rows, length, start);

                maxDuration = Math.max(maxDuration, duration);
                maxDelay = Math.max(maxDelay, delay);

                path.forEach((point, index) => {
                    const square = document.createElement('span');
                    square.className = 'ambient-square';
                    square.style.setProperty('--x', point.x);
                    square.style.setProperty('--y', point.y);
                    square.style.setProperty('--order', index);
                    square.style.setProperty('--duration', `${duration.toFixed(2)}s`);
                    square.style.setProperty('--delay', `${delay.toFixed(2)}s`);
                    container.appendChild(square);
                });
            });

            if (ambientRefreshTimer) clearTimeout(ambientRefreshTimer);
            const refreshMs = Math.max(12000, Math.ceil((maxDuration + maxDelay + 1) * 1000));
            ambientRefreshTimer = setTimeout(setupAmbientPaths, refreshMs);
        }

        function buildAmbientPath(cols, rows, length, start) {
            const path = [start];
            const used = new Set([coordKey(start)]);
            let current = start;
            let prev = null;

            for (let i = 1; i < length; i++) {
                const neighbors = [
                    { x: current.x + 1, y: current.y },
                    { x: current.x - 1, y: current.y },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x, y: current.y - 1 }
                ].filter(point => point.x >= 0 && point.x < cols && point.y >= 0 && point.y < rows);

                let options = neighbors;
                if (prev) {
                    options = options.filter(point => point.x !== prev.x || point.y !== prev.y);
                }
                const fresh = options.filter(point => !used.has(coordKey(point)));
                if (fresh.length) options = fresh;
                if (!options.length) options = neighbors;

                const next = options[Math.floor(Math.random() * options.length)];
                path.push(next);
                used.add(coordKey(next));
                prev = current;
                current = next;
            }

            return path;
        }

        function pickAmbientStart(cols, rows, starts, minDistance) {
            for (let attempt = 0; attempt < 40; attempt++) {
                const candidate = { x: getRandomInt(0, cols - 1), y: getRandomInt(0, rows - 1) };
                const isFar = starts.every(start =>
                    Math.abs(start.x - candidate.x) + Math.abs(start.y - candidate.y) >= minDistance
                );
                if (isFar) return candidate;
            }
            return { x: getRandomInt(0, cols - 1), y: getRandomInt(0, rows - 1) };
        }

        function parseCssTime(value, fallbackSec) {
            const raw = String(value || '').trim();
            const num = parseFloat(raw);
            if (!Number.isFinite(num)) return fallbackSec;
            return raw.endsWith('ms') ? num / 1000 : num;
        }

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function coordKey(point) {
            return `${point.x},${point.y}`;
        }

        function clamp(value, min, max) {
            return Math.min(max, Math.max(min, value));
        }

        /**
         * GAME LOGIC
         */
        function init() {
            const appVersionEl = document.getElementById('app-version');
            if (appVersionEl) appVersionEl.textContent = APP_VERSION;

            setupAmbientPaths();
            window.addEventListener('resize', () => {
                if (ambientResizeTimer) clearTimeout(ambientResizeTimer);
                ambientResizeTimer = setTimeout(setupAmbientPaths, 150);
            });

            // Load High Score
            updateMiniHighScore();
            
            // Event Listeners
            document.getElementById('btn-start').addEventListener('click', startGame);
            document.getElementById('btn-howto').addEventListener('click', showHowTo);
            document.getElementById('btn-leaderboard').addEventListener('click', showLeaderboard);
            document.getElementById('btn-close-leaderboard').addEventListener('click', hideLeaderboard);
            document.getElementById('btn-close-howto').addEventListener('click', hideHowTo);
            document.getElementById('btn-reset-data').addEventListener('click', resetData);
            document.getElementById('btn-next-level').addEventListener('click', advanceFromBreakdown);
            document.getElementById('btn-stage-start').addEventListener('click', startStage);
            document.getElementById('btn-retry').addEventListener('click', restartZone);
            document.getElementById('btn-home').addEventListener('click', goZones);
            document.getElementById('btn-zone-back').addEventListener('click', goHome);

            initHowToAnimations();
            updateHowToScoreDetails();
            initHowToScoreToggles();
        }

        function startGame() {
            clearLevelTransitionTimers();
            const name = ui.playerNameInput.value.trim() || "Player";
            state.player.name = name;
            showZoneSelect();
        }

        function restartZone() {
            beginZone(state.player.zoneIndex);
        }

        function resetPlayerForZone(zoneIndex) {
            state.player.score = 0;
            state.player.hearts = CONFIG.initialHearts;
            state.player.zoneIndex = zoneIndex;
            state.player.stageIndex = 0;
            state.player.levelIndex = 0;
        }

        function beginZone(zoneIndex) {
            resetPlayerForZone(zoneIndex);
            showStageIntro();
        }

        function goHome() {
            clearLevelTransitionTimers();
            showScreen('menu');
            applyZoneTheme(null);
            ui.hud.classList.add('hidden');
            ui.stageInfo.classList.add('hidden');
            ui.scoreDisplay.classList.add('hidden');
        }

        function goZones() {
            clearLevelTransitionTimers();
            showZoneSelect();
            ui.hud.classList.add('hidden');
            ui.stageInfo.classList.add('hidden');
            ui.scoreDisplay.classList.add('hidden');
        }

        function showHowTo() {
            showScreen('howto');
        }

        function hideHowTo() {
            showScreen('menu');
        }

        function initHowToAnimations() {
            const watchCells = Array.from(document.querySelectorAll('[data-watch-step]'))
                .sort((a, b) => Number(a.dataset.watchStep) - Number(b.dataset.watchStep));
            const repeatCells = Array.from(document.querySelectorAll('[data-repeat-step]'))
                .sort((a, b) => Number(a.dataset.repeatStep) - Number(b.dataset.repeatStep));

            if (!watchCells.length || !repeatCells.length) return;

            const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            if (prefersReducedMotion) {
                watchCells.forEach(cell => cell.classList.add('is-watch'));
                repeatCells.forEach(cell => cell.classList.add('is-repeat'));
                return;
            }

            if (howtoTimers.watch) clearTimeout(howtoTimers.watch);
            if (howtoTimers.repeat) clearTimeout(howtoTimers.repeat);

            const watchStepMs = 350;
            const watchPulseMs = 220;
            const watchPauseMs = 450;

            const runWatch = () => {
                watchCells.forEach((cell, index) => {
                    setTimeout(() => {
                        cell.classList.add('is-watch');
                        setTimeout(() => cell.classList.remove('is-watch'), watchPulseMs);
                    }, index * watchStepMs);
                });

                const totalMs = ((watchCells.length - 1) * watchStepMs) + watchPulseMs + watchPauseMs;
                howtoTimers.watch = setTimeout(runWatch, totalMs);
            };

            const repeatStepMs = 350;
            const repeatHoldMs = 650;
            const repeatResetMs = 450;

            const runRepeat = () => {
                repeatCells.forEach((cell, index) => {
                    setTimeout(() => {
                        cell.classList.add('is-repeat');
                    }, index * repeatStepMs);
                });

                const clearAtMs = ((repeatCells.length - 1) * repeatStepMs) + repeatHoldMs;
                setTimeout(() => {
                    repeatCells.forEach(cell => cell.classList.remove('is-repeat'));
                }, clearAtMs);

                howtoTimers.repeat = setTimeout(runRepeat, clearAtMs + repeatResetMs);
            };

            runWatch();
            runRepeat();
        }

        function updateHowToScoreDetails() {
            const baseEl = document.getElementById('howto-score-base');
            const timeEl = document.getElementById('howto-score-time');
            const stageEl = document.getElementById('howto-score-stage');
            const formulaEl = document.getElementById('howto-score-formula');

            if (!baseEl || !timeEl || !stageEl || !formulaEl) return;

            const baseScore = CONFIG.baseScorePerLevel;
            const timeBonusMax = CONFIG.scoring.timeBonusMultiplier;

            baseEl.textContent = `+${baseScore}`;
            timeEl.textContent = `+1 ~ +${timeBonusMax}`;
            stageEl.textContent = `x stage number`;
            formulaEl.textContent = `Score per level = (flat points + time bonus) x stage number`;
        }

        function initHowToScoreToggles() {
            const infoButtons = Array.from(document.querySelectorAll('[data-score-info]'));
            if (!infoButtons.length) return;

            infoButtons.forEach((button) => {
                button.addEventListener('click', () => {
                    const panelId = button.getAttribute('aria-controls');
                    if (!panelId) return;
                    const panel = document.getElementById(panelId);
                    if (!panel) return;

                    const willOpen = panel.classList.contains('hidden');
                    panel.classList.toggle('hidden');
                    button.setAttribute('aria-expanded', String(willOpen));
                });
            });
        }

        function getActiveZone() {
            return CONFIG.zones[state.player.zoneIndex];
        }

        function getZoneStages(zone) {
            if (zone && Array.isArray(zone.stages) && zone.stages.length) {
                return zone.stages;
            }
            return BASE_STAGES;
        }

        function getActiveStageConfig() {
            const zone = getActiveZone();
            return getZoneStages(zone)[state.player.stageIndex];
        }

        function getZoneTitle(zone, zoneIndex) {
            if (zone && zone.title) return zone.title;
            return `Zone ${zoneIndex + 1}`;
        }

        function showStageIntro() {
            const zone = getActiveZone();
            const stageConfig = getActiveStageConfig();
            const stageNumber = state.player.stageIndex + 1;
            const difficulty = CONFIG.stageDifficulty[state.player.stageIndex] || 'Unknown';
            const zoneTitle = getZoneTitle(zone, state.player.zoneIndex);
            const zoneStages = getZoneStages(zone);

            applyZoneTheme(zone);
            ui.hud.classList.add('hidden');
            ui.stageInfo.classList.add('hidden');
            ui.scoreDisplay.classList.add('hidden');
            updateHUD();
            if (ui.zoneTitle) ui.zoneTitle.textContent = zoneTitle;
            ui.stageTitle.textContent = `STAGE ${stageNumber}`;
            if (ui.stageCount) ui.stageCount.textContent = `of ${zoneStages.length}`;
            renderStageLevelDots(stageConfig.levels);
            ui.stageDifficulty.textContent = difficulty;
            showScreen('stage');
            playToneSequence(
                CONFIG.audio.stageIntroToneFreqsHz,
                CONFIG.audio.stageIntroToneType,
                CONFIG.audio.stageIntroToneDurationSec,
                CONFIG.audio.stageIntroToneDelayMs
            );
        }

        function showZoneSelect() {
            applyZoneTheme(null);
            renderZoneList();
            showScreen('zones');
        }

        function getZoneScoreStats(leaderboard, playerName) {
            const playerHighs = {};
            const topByZone = {};

            leaderboard.forEach((entry) => {
                if (!entry || !entry.name) return;
                const zone = Number(entry.zone);
                if (!Number.isFinite(zone)) return;
                const score = Number(entry.score) || 0;

                if (entry.name === playerName) {
                    const current = playerHighs[zone] || 0;
                    if (score > current) playerHighs[zone] = score;
                }

                const top = topByZone[zone];
                if (!top || score > top.score) {
                    topByZone[zone] = { score, name: entry.name };
                }
            });

            return { playerHighs, topByZone };
        }

        function renderZoneList() {
            if (!ui.zoneList) return;
            ui.zoneList.innerHTML = '';

            const leaderboard = getLeaderboard();
            const playerName = state.player.name || (ui.playerNameInput?.value.trim() || 'Player');
            const scoreStats = getZoneScoreStats(leaderboard, playerName);

            CONFIG.zones.forEach((zone, index) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'zone-card w-full text-left p-4 flex flex-col gap-2';
                const zoneTitle = getZoneTitle(zone, index);
                const themeName = zone?.theme?.name || 'Unknown';
                const color = zone?.theme?.color || '#38bdf8';
                const description = zone?.description || 'Step into the path and test your memory.';
                const isComingSoon = Boolean(zone?.comingSoon);
                const zoneNumber = index + 1;
                const playerHigh = scoreStats.playerHighs[zoneNumber];
                const topScore = scoreStats.topByZone[zoneNumber];
                const playerHighText = Number.isFinite(playerHigh) && playerHigh > 0 ? playerHigh : '';
                const topText = topScore ? `${topScore.score} (${topScore.name})` : '';

                button.style.setProperty('--zone-color', color);
                if (isComingSoon) {
                    button.disabled = true;
                    button.classList.add('is-locked');
                }
                const scoreLine = `Your High: ${playerHighText}  Top: ${topText}`;

                button.innerHTML = `
                    <div class="flex items-center justify-between gap-4">
                        <div>
                            <div class="zone-title">${zoneTitle}</div>
                            <div class="zone-subtitle">${themeName}</div>
                        </div>
                    </div>
                    <p class="text-sm text-muted leading-relaxed">${description}</p>
                    ${isComingSoon ? '' : `<div class="zone-meta">${scoreLine}</div>`}
                `;
                if (!isComingSoon) {
                    button.addEventListener('click', () => beginZone(index));
                }
                ui.zoneList.appendChild(button);
            });
        }

        function startStage() {
            clearLevelTransitionTimers();
            ui.hud.classList.remove('hidden');
            ui.stageInfo.classList.remove('hidden');
            ui.scoreDisplay.classList.remove('hidden');
            showScreen('game');
            setupLevel({ reusePath: false, hideOverlay: false });
            showLevelIntro(() => {
                queuePlayback();
            });
        }

        function updateHUD() {
            const zoneNumber = state.player.zoneIndex + 1;
            const stageNumber = state.player.stageIndex + 1;
            ui.stageInfo.textContent = `ZONE ${zoneNumber} - STAGE ${stageNumber}`;
            ui.scoreDisplay.textContent = state.player.score;

            const stageConfig = getActiveStageConfig();
            const totalLevels = stageConfig ? stageConfig.levels : 1;
            const currentLevel = state.player.levelIndex;
            if (ui.levelBreadcrumbs) {
                ui.levelBreadcrumbs.style.fontSize = `${CONFIG.ui.heartFontSizeRem}rem`;
                ui.levelBreadcrumbs.innerHTML = '';
                for (let i = 0; i < totalLevels; i++) {
                    const dot = document.createElement('div');
                    dot.className = 'level-dot';
                    if (i < currentLevel) {
                        dot.classList.add('complete');
                    } else if (i === currentLevel) {
                        dot.classList.add('current');
                    } else {
                        dot.classList.add('upcoming');
                    }
                    ui.levelBreadcrumbs.appendChild(dot);
                }
            }
            
            // Render Hearts
            ui.heartsContainer.innerHTML = '';
            for (let i = 0; i < CONFIG.initialHearts; i++) {
                const heart = document.createElement('span');
                heart.innerHTML = `
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                        <path fill="currentColor" d="M12 21s-6.713-4.477-9.6-8.23C.46 10.357.999 7.07 3.044 5.25 4.94 3.57 7.62 3.78 9.272 5.49L12 8.323l2.728-2.834c1.652-1.71 4.333-1.92 6.229-.24 2.045 1.82 2.584 5.107.644 7.52C18.713 16.523 12 21 12 21z"></path>
                    </svg>
                `;
                heart.className = i < state.player.hearts
                    ? 'heart-icon is-full'
                    : 'heart-icon is-empty';
                heart.style.fontSize = `${CONFIG.ui.heartFontSizeRem}rem`;
                ui.heartsContainer.appendChild(heart);
            }
        }

        function renderStageLevelDots(levelCount) {
            if (!ui.stageLevelDots) return;
            ui.stageLevelDots.style.fontSize = `${CONFIG.ui.heartFontSizeRem}rem`;
            ui.stageLevelDots.innerHTML = '';
            for (let i = 0; i < levelCount; i++) {
                const dot = document.createElement('div');
                dot.className = 'level-dot current stage-level-dot';
                ui.stageLevelDots.appendChild(dot);
            }
        }

        function setStatus(label, stateName) {
            if (!ui.statusText) return;
            ui.statusText.textContent = label;
            ui.statusText.dataset.state = stateName;
        }

        function setTimerState(stateName) {
            ui.timerBar.dataset.state = stateName;
        }

        function clearLevelTransitionTimers() {
            if (levelTransitionTimers.breakdownAuto) {
                clearTimeout(levelTransitionTimers.breakdownAuto);
                levelTransitionTimers.breakdownAuto = null;
            }
            if (levelTransitionTimers.levelIntro) {
                clearTimeout(levelTransitionTimers.levelIntro);
                levelTransitionTimers.levelIntro = null;
            }
            levelTransitionTimers.advanceTriggered = false;
            levelTransitionTimers.breakdownAdvance = null;
        }

        function scheduleLevelTransition() {
            clearLevelTransitionTimers();
            ui.overlayBreakdown.classList.remove('hidden');

            const stageConfig = getActiveStageConfig();
            const hasNextLevelInStage = (state.player.levelIndex + 1) < stageConfig.levels;
            const breakdownMs = CONFIG.levelTransition.breakdownAutoAdvanceMs
                ?? CONFIG.levelTransition.breakdownMs;

            ui.btnNext.classList.remove('hidden');
            ui.btnNext.classList.remove('is-counting');
            ui.btnNext.style.setProperty('--progress-duration', `${breakdownMs}ms`);
            void ui.btnNext.offsetWidth;
            ui.btnNext.classList.add('is-counting');

            levelTransitionTimers.breakdownAdvance = () => {
                if (levelTransitionTimers.advanceTriggered) return;
                levelTransitionTimers.advanceTriggered = true;
                if (levelTransitionTimers.breakdownAuto) {
                    clearTimeout(levelTransitionTimers.breakdownAuto);
                    levelTransitionTimers.breakdownAuto = null;
                }
                ui.btnNext.classList.add('hidden');
                ui.btnNext.classList.remove('is-counting');

                if (!hasNextLevelInStage) {
                    ui.overlay.classList.add('hidden');
                    nextLevel();
                    return;
                }

                state.player.levelIndex++;
                updateHUD();
                setupLevel({ reusePath: false, hideOverlay: false });
                showLevelIntro(() => {
                    queuePlayback();
                });
            };

            levelTransitionTimers.breakdownAuto = setTimeout(() => {
                advanceFromBreakdown();
            }, breakdownMs);
        }

        function advanceFromBreakdown() {
            if (typeof levelTransitionTimers.breakdownAdvance === 'function') {
                levelTransitionTimers.breakdownAdvance();
            } else {
                nextLevel();
            }
        }

        function showLevelIntro(onDone) {
            clearLevelTransitionTimers();
            if (ui.overlay) ui.overlay.classList.add('hidden');
            if (typeof onDone === 'function') {
                onDone();
            }
        }

        function setupLevel({ reusePath = false, hideOverlay = true } = {}) {
            if (hideOverlay) {
                ui.overlay.classList.add('hidden');
            }
            ui.pathOverlay.classList.add('hidden');
            state.status = 'WATCH';
            state.inputIndex = 0;
            setStatus("WATCH", "watch");
            ui.timerBar.style.width = '100%';
            setTimerState("watch");

            const stageConfig = getActiveStageConfig();
            const zone = getActiveZone();
            
            // 1. Generate Grid
            renderGrid(stageConfig.size);
            setGridInteractivity(false);

            // 2. Generate Path (unless reusing after a mistake)
            if (!reusePath || !Array.isArray(state.path) || state.path.length === 0) {
                const generated = PathGenerator.generate({
                    size: stageConfig.size,
                    levelIndex: state.player.levelIndex,
                    zone
                });
                state.path = generated.path || [];
                state.pathSegments = Array.isArray(generated.segments)
                    ? generated.segments
                    : state.path.map(() => 0);
            }

            if (!Array.isArray(state.pathSegments) || state.pathSegments.length !== state.path.length) {
                state.pathSegments = state.path.map(() => 0);
            }
        }

        function clearLevelGrid() {
            setGridInteractivity(false);
            ui.pathOverlay.classList.add('hidden');
            ui.grid.classList.add('grid-no-transitions');
            void ui.grid.offsetHeight;
            state.grid.forEach(({ el }) => {
                el.classList.remove('active', 'error', 'reveal', 'success', 'correct');
                el.style.pointerEvents = '';
            });
            requestAnimationFrame(() => {
                ui.grid.classList.remove('grid-no-transitions');
            });
        }

        function queuePlayback() {
            setTimeout(() => playSequence(), CONFIG.playback.startDelayMs);
        }

        function startLevel({ reusePath = false } = {}) {
            clearLevelTransitionTimers();
            setupLevel({ reusePath });
            queuePlayback();
        }

        function renderGrid(size) {
            ui.grid.innerHTML = '';
            ui.grid.style.width = '';
            ui.grid.style.height = '';
            ui.grid.style.gridTemplateColumns = `repeat(${size}, minmax(0, 1fr))`;
            ui.grid.style.gridTemplateRows = `repeat(${size}, minmax(0, 1fr))`;
            
            state.grid = [];
            for(let r=0; r<size; r++) {
                for(let c=0; c<size; c++) {
                    const cell = document.createElement('div');
                    // touch-none added to prevent scrolling interference
                    cell.className = "cell";
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    
                    // Unified Pointer Event Handler (Handles Touch and Mouse)
                    cell.addEventListener('pointerdown', (e) => {
                         e.preventDefault(); 
                         handleInput(r, c, cell);
                    });
                    
                    ui.grid.appendChild(cell);
                    state.grid.push({r, c, el: cell});
                }
            }

            requestAnimationFrame(() => fitGridToPixels(size));
        }

        function getCell(r, c) {
            return state.grid.find(item => item.r === r && item.c === c)?.el;
        }

        function fitGridToPixels(size) {
            const gridRect = ui.grid.getBoundingClientRect();
            if (!gridRect.width || !gridRect.height) return;

            const styles = window.getComputedStyle(ui.grid);
            const gapXRaw = parseFloat(styles.columnGap || styles.gap || 0);
            const gapYRaw = parseFloat(styles.rowGap || styles.gap || 0);
            const gapX = Number.isFinite(gapXRaw) ? gapXRaw : 0;
            const gapY = Number.isFinite(gapYRaw) ? gapYRaw : 0;
            const totalGapX = gapX * (size - 1);
            const totalGapY = gapY * (size - 1);

            const maxCellWidth = (gridRect.width - totalGapX) / size;
            const maxCellHeight = (gridRect.height - totalGapY) / size;
            let cellSize = Math.round(Math.min(maxCellWidth, maxCellHeight));

            if (!cellSize || cellSize <= 0) return;

            let gridWidth = (cellSize * size) + totalGapX;
            let gridHeight = (cellSize * size) + totalGapY;

            if (gridWidth > gridRect.width || gridHeight > gridRect.height) {
                cellSize = Math.floor(Math.min(maxCellWidth, maxCellHeight));
                gridWidth = (cellSize * size) + totalGapX;
                gridHeight = (cellSize * size) + totalGapY;
            }

            ui.grid.style.width = `${gridWidth}px`;
            ui.grid.style.height = `${gridHeight}px`;
            ui.grid.style.gridTemplateColumns = `repeat(${size}, ${cellSize}px)`;
            ui.grid.style.gridTemplateRows = `repeat(${size}, ${cellSize}px)`;
        }

        function setGridInteractivity(enabled) {
            ui.grid.classList.toggle('grid-locked', !enabled);
        }

        async function playSequence() {
            // Speed Calculation: Faster as stages progress
            const speed = Math.max(
                CONFIG.playback.speedMinMs,
                CONFIG.playback.speedBaseMs - (state.player.stageIndex * CONFIG.playback.speedDecrementPerStageMs)
            );
            const zone = getActiveZone();
            const segmentPauseMs = zone?.pathStyle === 'broken-diagonal'
                ? CONFIG.path.broken.segmentPauseMs
                : 0;
            const segmentIds = Array.isArray(state.pathSegments) ? state.pathSegments : [];
            
            for (let i = 0; i < state.path.length; i++) {
                if (segmentPauseMs && i > 0 && segmentIds[i] !== segmentIds[i - 1]) {
                    await new Promise(res => setTimeout(res, segmentPauseMs));
                }

                const {r, c} = state.path[i];
                const el = getCell(r, c);
                
                // Highlight
                el.classList.add('active');
                playTone(
                    CONFIG.playback.toneBaseHz + (i * CONFIG.playback.toneStepHz),
                    'sine',
                    CONFIG.playback.toneDurationSec
                ); // Audio feedback
                
                await new Promise(res => setTimeout(res, speed));
                
                // Unhighlight (keep a small gap if it's the same cell - though path gen usually moves)
                el.classList.remove('active');
                await new Promise(res => setTimeout(res, speed * CONFIG.playback.gapRatio));
            }

            beginInputPhase();
        }

        function updateRevealPathLine(startIndex) {
            const gridRect = ui.grid.getBoundingClientRect();
            const containerRect = screens.game.getBoundingClientRect();

            if (!gridRect.width || !gridRect.height) return false;

            const left = gridRect.left - containerRect.left;
            const top = gridRect.top - containerRect.top;

            ui.pathOverlay.style.left = `${left}px`;
            ui.pathOverlay.style.top = `${top}px`;
            ui.pathOverlay.style.width = `${gridRect.width}px`;
            ui.pathOverlay.style.height = `${gridRect.height}px`;
            ui.pathOverlay.setAttribute('viewBox', `0 0 ${gridRect.width} ${gridRect.height}`);

            const segment = state.path.slice(startIndex);
            const segmentIds = Array.isArray(state.pathSegments)
                ? state.pathSegments.slice(startIndex)
                : [];
            const points = segment.map(({r, c}, index) => {
                const el = getCell(r, c);
                if (!el) return null;
                const rect = el.getBoundingClientRect();
                return {
                    x: rect.left - gridRect.left + rect.width / 2,
                    y: rect.top - gridRect.top + rect.height / 2,
                    segmentId: segmentIds[index] ?? 0
                };
            }).filter(Boolean);

            if (points.length < 2) return false;

            let d = `M ${points[0].x} ${points[0].y}`;
            for (let i = 1; i < points.length; i++) {
                const cmd = points[i].segmentId !== points[i - 1].segmentId ? 'M' : 'L';
                d += ` ${cmd} ${points[i].x} ${points[i].y}`;
            }
            ui.pathLine.setAttribute('d', d);

            const length = ui.pathLine.getTotalLength();
            ui.pathLine.dataset.length = length;
            ui.pathLine.style.strokeDasharray = length;
            ui.pathLine.style.strokeDashoffset = length;
            return true;
        }

        function revealPathBriefly(startIndex, onDone) {
            const start = Math.max(0, startIndex || 0);
            const hasLine = updateRevealPathLine(start);
            const completedCells = state.path.slice(0, start).map(({r, c}) => getCell(r, c)).filter(Boolean);
            setGridInteractivity(false);

            if (hasLine) {
                ui.pathLine.style.transition = 'none';
                void ui.pathLine.getBoundingClientRect();
                ui.pathOverlay.classList.remove('hidden');
                ui.pathLine.style.transition = `stroke-dashoffset ${CONFIG.reveal.mistakeMs}ms ease-out`;
                ui.pathLine.style.strokeDashoffset = '0';
            }

            state.path.slice(start).forEach(({r, c}) => {
                const el = getCell(r, c);
                if (!el) return;
                el.classList.add('reveal');
            });

            setTimeout(() => {
                state.path.slice(start).forEach(({r, c}) => {
                    const el = getCell(r, c);
                    if (!el) return;
                    el.classList.remove('reveal');
                });
                completedCells.forEach((el) => {
                    el.classList.remove('correct');
                    el.style.pointerEvents = '';
                });
                if (hasLine) {
                    const length = Number(ui.pathLine.dataset.length || 0);
                    ui.pathLine.style.transition = 'none';
                    ui.pathLine.style.strokeDashoffset = length;
                    ui.pathOverlay.classList.add('hidden');
                }
                setGridInteractivity(true);
                if (typeof onDone === 'function') {
                    onDone();
                }
            }, CONFIG.reveal.mistakeMs);
        }

        function beginInputPhase() {
            state.status = 'INPUT';
            setStatus("YOUR TURN", "input");
            setTimerState("input");
            setGridInteractivity(true);

            // Timer Setup
            // Time depends on path length + complexity
            const timePerSquare = Math.max(
                CONFIG.input.timePerSquareMinSec,
                CONFIG.input.timePerSquareBaseSec - (state.player.stageIndex * CONFIG.input.timePerSquareStagePenaltySec)
            );
            state.maxTime = state.path.length * timePerSquare * CONFIG.timing.msPerSecond;
            state.timerValue = state.maxTime;
            
            if (state.timer) clearInterval(state.timer);
            
            const tickRate = CONFIG.input.tickRateMs;
            state.timer = setInterval(() => {
                state.timerValue -= tickRate;
                const pct = (state.timerValue / state.maxTime) * 100;
                ui.timerBar.style.width = `${pct}%`;

                // Change color if low
                if (pct < CONFIG.input.lowTimeThresholdPct && ui.timerBar.dataset.state !== 'danger') {
                    setTimerState("danger");
                }

                if (state.timerValue <= 0) {
                    handleMistake("TIME UP");
                }
            }, tickRate);
        }

        function handleInput(r, c, el) {
            if (state.status !== 'INPUT') return;

            const target = state.path[state.inputIndex];

            // Feedback Animation
            el.classList.remove('active');
            void el.offsetWidth; // trigger reflow

            if (r === target.r && c === target.c) {
                // Correct
                el.classList.add('success');
                el.classList.add('correct');
                el.style.pointerEvents = 'none';
                playTone(
                    CONFIG.input.correctToneBaseHz + (state.inputIndex * CONFIG.input.correctToneStepHz),
                    'triangle',
                    CONFIG.input.correctToneDurationSec
                );
                
                setTimeout(() => el.classList.remove('success'), CONFIG.input.successClearMs);
                
                state.inputIndex++;

                if (state.inputIndex >= state.path.length) {
                    completeLevel();
                }
            } else {
                // Wrong
                el.classList.add('error');
                playTone(CONFIG.input.wrongToneHz, 'sawtooth', CONFIG.input.wrongToneDurationSec);
                setTimeout(() => el.classList.remove('error'), CONFIG.input.errorClearMs);
                handleMistake("WRONG");
            }
        }

        function handleMistake(reason) {
            clearInterval(state.timer);

            // Add sound for Time Up
            if (reason === "TIME UP") {
                playTone(CONFIG.input.timeUpToneHz, 'sawtooth', CONFIG.input.timeUpToneDurationSec);
            }

            state.status = 'FAIL';
            
            state.player.hearts--;
            updateHUD();

            setStatus("PATH", "path");

            revealPathBriefly(state.inputIndex, () => {
                if (state.player.hearts <= 0) {
                    gameOver();
                    return;
                }

                // Brief pause then replay pattern
                setStatus("TRY AGAIN", "retry");
                setTimeout(() => {
                    startLevel({ reusePath: true });
                }, CONFIG.input.retryDelayMs);
            });
        }

        function completeLevel() {
            clearInterval(state.timer);
            state.status = 'SUCCESS';
            
            // Calculate Score
            // Score = (base + time bonus) x stage number
            const baseScore = CONFIG.baseScorePerLevel;
            const timeBonus = 1 + Math.floor((state.timerValue / state.maxTime) * CONFIG.scoring.timeBonusMultiplier);
            const stageNumber = state.player.stageIndex + 1;
            const levelScore = (baseScore + timeBonus) * stageNumber;
            state.player.score += levelScore;
            
            updateHUD();
            clearLevelGrid();

            // Show Overlay
            if (ui.overlayIntro) ui.overlayIntro.classList.add('hidden');
            ui.overlayTitle.classList.remove('hidden');
            ui.overlayTitle.textContent = "LEVEL COMPLETE";
            ui.overlayBaseScore.textContent = `+${baseScore}`;
            ui.overlayTimeBonus.textContent = `+${timeBonus}`;
            ui.overlayStageBonus.textContent = `x${stageNumber}`;
            ui.overlayTotalScore.textContent = `+${levelScore}`;
            const continueLabel = ui.btnNext.querySelector('span');
            if (continueLabel) continueLabel.textContent = "CONTINUE";
            ui.overlay.classList.remove('hidden');
            ui.overlayBreakdown.classList.remove('hidden');

            if (CONFIG.audio.successToneFreqsHz.length > 0) {
                playTone(CONFIG.audio.successToneFreqsHz[0], 'sine', CONFIG.audio.successToneDurationSec);
            }
            if (CONFIG.audio.successToneFreqsHz.length > 1) {
                setTimeout(() => {
                    playTone(CONFIG.audio.successToneFreqsHz[1], 'sine', CONFIG.audio.successToneDurationSec);
                }, CONFIG.audio.successToneDelayMs);
            }

            scheduleLevelTransition();
        }

        function nextLevel() {
            clearLevelTransitionTimers();
            ui.overlay.classList.add('hidden');
            state.player.levelIndex++;
            
            // Check for Stage Progression
            const stageConfig = getActiveStageConfig();
            const zoneStages = getZoneStages(getActiveZone());

            if (state.player.levelIndex >= stageConfig.levels) {
                state.player.stageIndex++;
                state.player.levelIndex = 0;
                
                if (state.player.stageIndex >= zoneStages.length) {
                    zoneComplete();
                    return;
                }

                showStageIntro();
                return;
            }

            updateHUD(); 
            startLevel();
        }

        function gameOver() {
            state.status = 'GAMEOVER';
            saveScore(
                state.player.name,
                state.player.score,
                state.player.zoneIndex,
                state.player.stageIndex,
                state.player.levelIndex
            );
            
            ui.finalScore.textContent = state.player.score;
            ui.gameOverTitle.textContent = 'GAME OVER';
            ui.gameOverTitle.className = GAME_OVER_TITLE_CLASS;
            const messages = Array.isArray(CONFIG.gameOverMessages) ? CONFIG.gameOverMessages : [];
            ui.gameOverMark.textContent = messages.length ? getRandomItem(messages) : 'Good try!';
            ui.gameOverMark.className = GAME_OVER_MARK_CLASS;
            ui.gameOverDescription.textContent = '';
            showScreen('game-over');
            playToneSequence(
                CONFIG.audio.gameOverToneFreqsHz,
                CONFIG.audio.gameOverToneType,
                CONFIG.audio.gameOverToneDurationSec,
                CONFIG.audio.gameOverToneDelayMs
            );
        }

        function zoneComplete() {
            state.status = 'GAMEOVER';
            const activeZoneIndex = state.player.zoneIndex;
            const activeZone = getActiveZone();
            const zoneStages = getZoneStages(activeZone);
            const lastStageIndex = Math.max(0, zoneStages.length - 1);
            const lastStage = zoneStages[lastStageIndex];
            const lastLevelIndex = lastStage ? lastStage.levels - 1 : 0;

            saveScore(
                state.player.name,
                state.player.score,
                activeZoneIndex,
                lastStageIndex,
                lastLevelIndex
            );
            
            ui.finalScore.textContent = state.player.score;
            ui.gameOverTitle.textContent = 'ZONE CLEARED';
            ui.gameOverTitle.className = VICTORY_TITLE_CLASS;
            ui.gameOverMark.textContent = '';
            ui.gameOverMark.className = VICTORY_MARK_CLASS;
            ui.gameOverDescription.textContent = '';
            
            showScreen('game-over');
            playToneSequence(
                CONFIG.audio.victoryToneFreqsHz,
                CONFIG.audio.victoryToneType,
                CONFIG.audio.victoryToneDurationSec,
                CONFIG.audio.victoryToneDelayMs
            );
        }

        /**
         * PERSISTENCE & LEADERBOARD
         */
        function getLeaderboard() {
            const data = localStorage.getItem(CONFIG.localStorageKey);
            if (!data) return [];
            try {
                const parsed = JSON.parse(data);
                return Array.isArray(parsed) ? parsed : [];
            } catch (error) {
                return [];
            }
        }

        function getLeaderboardZoneNumbers() {
            const zoneNumbers = CONFIG.zones.reduce((list, zone, index) => {
                if (zone && zone.comingSoon) return list;
                list.push(index + 1);
                return list;
            }, []);
            return zoneNumbers.slice(0, 3);
        }

        function getPlayerSummaries(leaderboard) {
            const zoneNumbers = getLeaderboardZoneNumbers();
            const players = new Map();

            leaderboard.forEach((entry) => {
                if (!entry || !entry.name) return;
                const zone = Number(entry.zone);
                if (!zoneNumbers.includes(zone)) return;
                const score = Number(entry.score) || 0;
                let summary = players.get(entry.name);
                if (!summary) {
                    summary = { name: entry.name, zones: {}, total: 0 };
                    players.set(entry.name, summary);
                }
                if (!(zone in summary.zones) || score > summary.zones[zone]) {
                    summary.zones[zone] = score;
                }
            });

            const summaries = Array.from(players.values());
            summaries.forEach((summary) => {
                summary.total = zoneNumbers.reduce((sum, zone) => sum + (summary.zones[zone] || 0), 0);
            });

            summaries.sort((a, b) => {
                if (b.total !== a.total) return b.total - a.total;
                return a.name.localeCompare(b.name);
            });

            return { summaries, zoneNumbers };
        }

        function getPlayerTotalScore(name, leaderboard) {
            if (!name) return 0;
            const { summaries } = getPlayerSummaries(leaderboard || getLeaderboard());
            const player = summaries.find((summary) => summary.name === name);
            return player ? player.total : 0;
        }

        function saveScore(name, score, zoneIndex, stageIndex, levelIndex) {
            let lb = getLeaderboard();
            const zone = Number.isInteger(zoneIndex) ? zoneIndex + 1 : null;
            const stage = Number.isInteger(stageIndex) ? stageIndex + 1 : null;
            const level = Number.isInteger(levelIndex) ? levelIndex + 1 : null;
            
            // Check if user has a score for this zone, update if higher
            const existingIndex = lb.findIndex(entry => entry.name === name && entry.zone === zone);
            if (existingIndex > -1) {
                if (score > lb[existingIndex].score) {
                    lb[existingIndex].score = score;
                    lb[existingIndex].stage = stage;
                    lb[existingIndex].level = level;
                    lb[existingIndex].date = new Date().toISOString();
                }
            } else {
                lb.push({ name, score, zone, stage, level, date: new Date().toISOString() });
            }

            localStorage.setItem(CONFIG.localStorageKey, JSON.stringify(lb));
            updateMiniHighScore();
        }

        function updateMiniHighScore() {
            const lb = getLeaderboard();
            const { summaries } = getPlayerSummaries(lb);
            const high = summaries.length ? summaries[0].total : 0;
            if (ui.highScoreMini) {
                ui.highScoreMini.textContent = `HI: ${high}`;
            }
        }

        function showLeaderboard() {
            const lb = getLeaderboard();
            ui.leaderboardBody.innerHTML = '';
            const { summaries, zoneNumbers } = getPlayerSummaries(lb);

            if (summaries.length === 0) {
                ui.leaderboardBody.innerHTML = '<tr><td colspan="6" class="p-4 text-center text-muted">No scores yet. Be the first!</td></tr>';
            } else {
                summaries.forEach((summary, idx) => {
                    const row = document.createElement('tr');
                    row.className = idx < CONFIG.leaderboard.highlightTopCount
                        ? 'leaderboard-row is-highlight'
                        : 'leaderboard-row';
                    const icon = CONFIG.leaderboard.topRankIcons[idx]
                        ? `${CONFIG.leaderboard.topRankIcons[idx]} `
                        : '';

                    const zoneValues = zoneNumbers.map((zone) => {
                        const hasScore = Object.prototype.hasOwnProperty.call(summary.zones, zone);
                        const scoreText = hasScore ? summary.zones[zone] : '';
                        const classes = hasScore ? '' : 'text-muted';
                        return `<td class="p-3 text-right font-mono ${classes}">${scoreText}</td>`;
                    }).join('');

                    row.innerHTML = `
                        <td class="p-3">${icon}#${idx + 1}</td>
                        <td class="p-3 truncate max-w-[140px]">${summary.name}</td>
                        ${zoneValues}
                        <td class="p-3 text-right font-mono">${summary.total}</td>
                    `;
                    ui.leaderboardBody.appendChild(row);
                });
            }
            screens.leaderboard.classList.remove('hidden');
        }

        function hideLeaderboard() {
            screens.leaderboard.classList.add('hidden');
        }

        function resetData() {
            if(confirm("Clear all leaderboard data? This cannot be undone.")) {
                localStorage.removeItem(CONFIG.localStorageKey);
                showLeaderboard(); // Refresh view
                updateMiniHighScore();
            }
        }

        /**
         * UTILS & AUDIO
         */
        function showScreen(screenName) {
            Object.values(screens).forEach(s => s.classList.add('hidden'));
            if (screenName === 'menu') screens.menu.classList.remove('hidden');
            if (screenName === 'zones') screens.zones.classList.remove('hidden');
            if (screenName === 'stage') screens.stage.classList.remove('hidden');
            if (screenName === 'game') screens.game.classList.remove('hidden');
            if (screenName === 'howto') screens.howto.classList.remove('hidden');
            if (screenName === 'game-over') screens.gameOver.classList.remove('hidden');

            if (screenName === 'game') {
                ui.header.classList.remove('hidden');
            } else {
                ui.header.classList.add('hidden');
            }
        }

        // Simple Web Audio API for feedback
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playTone(freq, type, duration) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            
            gain.gain.setValueAtTime(CONFIG.audio.gainStart, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(CONFIG.audio.gainEnd, audioCtx.currentTime + duration);
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }
        
        function playToneSequence(freqs, type, duration, delayMs) {
            if (!Array.isArray(freqs) || freqs.length === 0) return;
            freqs.forEach((freq, index) => {
                setTimeout(() => {
                    playTone(freq, type, duration);
                }, index * delayMs);
            });
        }

        function getRandomItem(items) {
            return items[Math.floor(Math.random() * items.length)];
        }

        function applyZoneTheme(zone) {
            const fallback = { color: '#38bdf8', name: 'Cyber Blue' };
            const theme = (zone && zone.theme) ? zone.theme : fallback;
            const color = theme.color || fallback.color;
            const root = document.documentElement;
            root.style.setProperty('--theme-color', color);
            root.style.setProperty('--theme-shadow', rgbaFromHex(color, 0.5));
            root.style.setProperty('--theme-shadow-soft', rgbaFromHex(color, 0.3));
            root.style.setProperty('--theme-ambient', rgbaFromHex(color, 0.22));
        }

        function rgbaFromHex(hex, alpha) {
            const rgb = hexToRgb(hex);
            if (!rgb) return `rgba(56, 189, 248, ${alpha})`;
            return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
        }

        function hexToRgb(hex) {
            if (!hex) return null;
            let raw = String(hex).trim();
            if (raw.startsWith('#')) raw = raw.slice(1);
            if (raw.length === 3) {
                raw = raw.split('').map(ch => ch + ch).join('');
            }
            if (raw.length !== 6) return null;
            const int = Number.parseInt(raw, 16);
            if (!Number.isFinite(int)) return null;
            return {
                r: (int >> 16) & 255,
                g: (int >> 8) & 255,
                b: int & 255
            };
        }

        // Init
        init();

    </script>
</body>
</html>
