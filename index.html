<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REMEMBER The Path</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Prevent double-tap zoom */
            user-select: none;
            --grid-size: 48px;
            --ambient-step: 0.8s;
            --ambient-duration: 20s;
        }

        body::before {
            content: "";
            position: fixed;
            inset: 0;
            background:
                linear-gradient(to right, rgba(148, 163, 184, 0.12) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(148, 163, 184, 0.12) 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
            opacity: 0.6;
            pointer-events: none;
            z-index: 0;
        }

        #ambient-paths {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;
        }

        .ambient-square {
            position: absolute;
            width: var(--grid-size);
            height: var(--grid-size);
            left: calc(var(--grid-size) * var(--x));
            top: calc(var(--grid-size) * var(--y));
            border-radius: 8px;
            background: rgba(56, 189, 248, 0.22);
            box-shadow: 0 0 0 rgba(56, 189, 248, 0);
            opacity: 0;
            animation: ambient-glow var(--duration, var(--ambient-duration)) linear infinite;
            animation-delay: calc(var(--delay, 0s) + (var(--order) * var(--ambient-step)));
        }

        #app {
            position: relative;
            z-index: 1;
        }

        /* Custom Scrollbar for Leaderboard */
        .custom-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: #1f2937;
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 3px;
        }

        /* Grid Cell Animations */
        .cell {
            transition: all 0.2s ease;
        }

        .grid-no-transitions .cell {
            transition: none !important;
        }

        @media (hover: none) {
            .cell:hover {
                background-color: #374151; /* Match bg-gray-700 to avoid sticky hover on touch */
            }
        }

        .grid-locked {
            pointer-events: none;
        }
        
        .cell.active {
            background-color: #38bdf8; /* Sky 400 */
            box-shadow: 0 0 15px #38bdf8;
            transform: scale(0.95);
        }

        .cell.success {
            background-color: #4ade80; /* Green 400 */
            box-shadow: 0 0 15px #4ade80;
        }

        .cell.correct {
            background-color: #4ade80; /* Green 400 */
            box-shadow: 0 0 15px #4ade80;
        }

        .cell.error {
            background-color: #f87171; /* Red 400 */
            box-shadow: 0 0 15px #f87171;
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

        .cell.reveal {
            background-color: #f59e0b; /* Amber 500 */
            box-shadow: 0 0 15px #f59e0b;
        }

        .menu-title {
            font-size: clamp(2.5rem, 8vw, 4.75rem);
            font-weight: 800;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            background: linear-gradient(90deg, #38bdf8, #a855f7, #38bdf8);
            background-size: 200% auto;
            -webkit-background-clip: text;
            color: transparent;
            text-shadow: 0 0 18px rgba(56, 189, 248, 0.35);
            animation: title-glide 6s linear infinite;
        }

        .path-overlay {
            position: absolute;
            z-index: 5;
            pointer-events: none;
        }

        .path-line {
            stroke: #fbbf24;
            stroke-width: 6;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 0 6px rgba(245, 158, 11, 0.6));
        }

        .howto-card {
            background: rgba(17, 24, 39, 0.92);
            border: 1px solid #374151;
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
            animation: howto-rise 0.55s ease both;
        }

        .howto-step {
            font-size: 10px;
            letter-spacing: 0.28em;
            text-transform: uppercase;
            color: #64748b;
        }

        .howto-section {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 11px;
            letter-spacing: 0.32em;
            text-transform: uppercase;
            color: #94a3b8;
            padding: 2px 2px 0;
        }

        .howto-section::after {
            content: "";
            flex: 1;
            height: 1px;
            background: #1f2937;
        }

        .howto-visual {
            background: #0b1220;
            border: 1px solid #1f2937;
            border-radius: 14px;
            padding: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .howto-grid {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 6px;
            width: 140px;
            height: 140px;
        }

        .howto-cell {
            position: relative;
            border-radius: 6px;
            background: #1f2937;
            border: 1px solid #334155;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }

        .howto-cell.is-watch {
            background: #38bdf8;
            box-shadow: 0 0 12px rgba(56, 189, 248, 0.65);
        }

        .howto-cell.is-repeat {
            background: #4ade80;
            box-shadow: 0 0 12px rgba(74, 222, 128, 0.65);
        }

        .howto-timer {
            width: 100%;
            height: 10px;
            background: #1f2937;
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid #334155;
        }

        .howto-timer span {
            display: block;
            height: 100%;
            width: 70%;
            background: linear-gradient(90deg, #38bdf8, #60a5fa);
            animation: howto-sweep 2.8s ease-in-out infinite;
        }

        .howto-hearts {
            display: flex;
            gap: 6px;
        }

        .howto-heart {
            width: 20px;
            height: 20px;
        }

        .howto-score-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .howto-info-btn {
            width: 18px;
            height: 18px;
            border-radius: 999px;
            border: 1px solid #334155;
            background: #111827;
            color: #94a3b8;
            font-size: 11px;
            font-weight: 600;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: border-color 0.2s ease, color 0.2s ease, background 0.2s ease;
        }

        .howto-info-btn:hover {
            border-color: #38bdf8;
            color: #38bdf8;
        }

        .howto-info-btn:focus-visible {
            outline: 2px solid rgba(56, 189, 248, 0.5);
            outline-offset: 2px;
        }

        .howto-score-info {
            border-left: 2px solid #1f2937;
            margin: 4px 0 2px;
            padding-left: 8px;
            font-size: 11px;
            color: #94a3b8;
            line-height: 1.5;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        @keyframes title-glide {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        @keyframes howto-rise {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes howto-sweep {
            0%, 100% { width: 92%; }
            50% { width: 35%; }
        }

        @keyframes ambient-glow {
            0% {
                opacity: 0;
                box-shadow: 0 0 0 rgba(56, 189, 248, 0);
            }
            1.5% {
                opacity: 0.35;
                box-shadow: 0 0 18px rgba(56, 189, 248, 0.5);
            }
            3% {
                opacity: 0.18;
                box-shadow: 0 0 10px rgba(56, 189, 248, 0.3);
            }
            4% {
                opacity: 0;
                box-shadow: 0 0 0 rgba(56, 189, 248, 0);
            }
            100% {
                opacity: 0;
                box-shadow: 0 0 0 rgba(56, 189, 248, 0);
            }
        }

        @media (prefers-reduced-motion: reduce) {
            .menu-title {
                animation: none;
            }

            .howto-card,
            .howto-timer span {
                animation: none;
            }

            .ambient-square {
                animation: none;
                opacity: 0.12;
                box-shadow: 0 0 10px rgba(56, 189, 248, 0.25);
            }
        }

        /* Timer Bar Animation */
        .timer-bar {
            transition: width 0.1s linear;
        }

        .heart-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .heart-icon svg {
            width: 1em;
            height: 1em;
            display: block;
        }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen flex flex-col overflow-hidden">
    <div id="ambient-paths" aria-hidden="true"></div>

    <!-- Game Container -->
    <div id="app" class="flex-1 flex flex-col relative max-w-lg mx-auto w-full h-full">
        
        <!-- HEADER / HUD -->
        <header id="hud-header" class="p-4 bg-gray-800 border-b border-gray-700 shadow-md z-10 hidden">
            <div class="flex justify-between items-center mb-2">
                <div>
                    <h1 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">REMEMBER THE PATH</h1>
                    <div id="stage-info" class="text-xs text-gray-400 font-mono hidden">STAGE 1 - LVL 1</div>
                </div>
                <div class="text-right">
                    <div id="score-display" class="text-2xl font-bold text-yellow-400 hidden">0</div>
                    <div id="high-score-mini" class="text-xs text-gray-500 hidden">HI: 0</div>
                </div>
            </div>
            
            <!-- Hearts & Timer HUD -->
            <div id="game-hud" class="hidden flex flex-col gap-2">
                <div class="flex justify-between items-center">
                    <div id="hearts-container" class="flex gap-1 text-red-500">
                        <!-- Hearts injected here -->
                    </div>
                    <div id="status-text" class="text-sm font-semibold text-blue-300 uppercase tracking-wider">WAIT</div>
                </div>
                <!-- Timer Bar -->
                <div class="w-full bg-gray-700 h-5 rounded-full overflow-hidden">
                    <div id="timer-bar" class="h-full bg-blue-500 w-full"></div>
                </div>
            </div>
        </header>

        <!-- MAIN CONTENT AREA -->
        <main class="flex-1 relative flex items-center justify-center p-4">
            
            <!-- MENU SCREEN -->
            <div id="menu-screen" class="absolute inset-0 z-20 flex flex-col items-center justify-center p-6 space-y-6">
                <div class="text-center space-y-3">
                    <h1 id="menu-title" class="menu-title">REMEMBER THE PATH</h1>
                </div>
                
                <div class="w-full max-w-xs space-y-4">
                    <div>
                        <label class="block text-xs text-gray-500 mb-1 uppercase tracking-wide">Player Name</label>
                        <input type="text" id="player-name" class="w-full bg-gray-800 border border-gray-700 rounded p-3 text-white focus:outline-none focus:border-blue-500 transition" placeholder="Enter name" maxlength="10">
                    </div>
                    <button id="btn-start" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded shadow-lg transform transition active:scale-95">START GAME</button>
                    <button id="btn-howto" class="w-full bg-gray-700 hover:bg-gray-600 text-gray-200 font-semibold py-3 px-4 rounded shadow transform transition active:scale-95">HOW TO PLAY</button>
                    <button id="btn-leaderboard" class="w-full bg-gray-700 hover:bg-gray-600 text-gray-300 font-semibold py-3 px-4 rounded shadow transform transition active:scale-95">LEADERBOARD</button>
                </div>
            </div>

            <!-- STAGE INTRO SCREEN -->
            <div id="stage-screen" class="hidden absolute inset-0 z-20 flex flex-col items-center justify-center p-6 space-y-6">
                <div class="text-center space-y-2">
                    <div class="text-xs text-gray-500 uppercase tracking-widest"></div>
                    <h2 id="stage-title" class="text-4xl font-extrabold text-white">STAGE 1</h2>
                </div>
                <div class="w-full max-w-xs bg-gray-800/70 border border-gray-700 rounded-lg p-4 text-center">
                    <div class="text-sm text-gray-500 uppercase tracking-widest mb-1">Difficulty</div>
                    <div id="stage-difficulty" class="text-2xl font-bold text-amber-400">Piece of Cake</div>
                    <div class="mt-4 w-24 mx-auto border-t border-gray-700"></div>
                    <div class="mt-3">
                        <div class="text-sm text-gray-500 uppercase tracking-widest">Levels</div>
                        <span id="stage-level-count" class="text-2xl font-bold text-amber-400">5</span>
                    </div>
                </div>
                <button id="btn-stage-start" class="w-full max-w-xs bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded shadow-lg transform transition active:scale-95">START STAGE</button>
            </div>

            <!-- GRID CONTAINER -->
            <div id="game-container" class="hidden relative flex items-center justify-center w-full aspect-square max-w-[400px] bg-gray-800 rounded-xl p-2 shadow-2xl border border-gray-700">
                <div id="grid" class="w-full h-full grid gap-1.5 sm:gap-2">
                    <!-- Grid cells generated by JS -->
                </div>

                <!-- Path reveal overlay -->
                <svg id="path-overlay" class="path-overlay hidden">
                    <defs>
                        <marker id="path-arrow" markerWidth="5" markerHeight="5" refX="4" refY="2.5" orient="auto">
                            <path d="M 0 0 L 5 2.5 L 0 5 z" fill="#fbbf24"></path>
                        </marker>
                    </defs>
                    <path id="path-line" class="path-line" marker-end="url(#path-arrow)"></path>
                </svg>
                
                <!-- Overlay for "Level Complete" / "Get Ready" -->
                <div id="overlay-message" class="absolute inset-0 z-10 bg-gray-900/90 flex flex-col items-center justify-center text-center hidden backdrop-blur-sm rounded-xl">
                    <h3 id="overlay-title" class="text-2xl font-bold text-white mb-2">LEVEL COMPLETE</h3>
                    <div id="overlay-breakdown" class="w-full max-w-xs bg-gray-800/70 border border-gray-700 rounded-lg p-4 mb-5 text-left">
                        <div class="flex justify-between text-[11px] uppercase tracking-wider text-gray-400 mb-2">
                            <span>Score Breakdown</span>
                            <span>Pts</span>
                        </div>
                        <div class="space-y-1 text-sm">
                            <div class="flex justify-between">
                                <span class="text-gray-300">Level Cleared</span>
                                <span id="overlay-score-base" class="font-mono text-yellow-300">+0</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-300">Time Bonus</span>
                                <span id="overlay-score-time" class="font-mono text-yellow-300">+0</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-300">Stage Bonus</span>
                                <span id="overlay-score-stage" class="font-mono text-yellow-300">+0</span>
                            </div>
                        </div>
                        <div class="mt-2 pt-2 border-t border-gray-700 flex justify-between text-sm font-semibold">
                            <span class="text-gray-200">Total</span>
                            <span id="overlay-score-total" class="font-mono text-yellow-300">+0</span>
                        </div>
                    </div>
                    <button id="btn-next-level" class="bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-6 rounded-full shadow-lg transform transition active:scale-95 hidden">NEXT LEVEL</button>
                </div>
            </div>

            <!-- LEADERBOARD SCREEN -->
            <div id="leaderboard-screen" class="hidden absolute inset-0 z-30 flex flex-col p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-white">Leaderboard</h2>
                    <button id="btn-close-leaderboard" class="bg-gray-700 hover:bg-gray-600 text-gray-200 text-xs font-semibold uppercase tracking-wider py-2 px-3 rounded-md border border-gray-600 shadow">Close</button>
                </div>
                <div class="flex-1 overflow-y-auto custom-scroll bg-gray-800 rounded-lg border border-gray-700">
                    <table class="w-full text-left border-collapse">
                        <thead class="bg-gray-700 text-xs text-gray-400 uppercase sticky top-0">
                            <tr>
                                <th class="p-3">Rank</th>
                                <th class="p-3">Player</th>
                                <th class="p-3">Stage/Level</th>
                                <th class="p-3 text-right">Score</th>
                            </tr>
                        </thead>
                        <tbody id="leaderboard-body" class="text-sm">
                            <!-- Rows injected here -->
                        </tbody>
                    </table>
                </div>
                <div class="mt-4 text-center">
                    <button id="btn-reset-data" class="text-xs text-red-500 hover:text-red-400 underline">Clear Data</button>
                </div>
            </div>

            <!-- HOW TO PLAY SCREEN -->
            <div id="howto-screen" class="hidden absolute inset-0 z-30 flex flex-col p-6">
                <div class="flex items-start justify-between gap-4 mb-5">
                    <div>
                        <h2 class="text-3xl font-extrabold text-white mt-1">How To Play</h2>
                        <p class="text-sm text-gray-400 mt-1 max-w-sm">Watch the pattern, tap it back, and outrun the timer.</p>
                    </div>
                    <button id="btn-close-howto" class="bg-gray-700 hover:bg-gray-600 text-gray-200 text-xs font-semibold uppercase tracking-wider py-2 px-3 rounded-md border border-gray-600 shadow">Back</button>
                </div>
                <div class="flex-1 overflow-y-auto custom-scroll pr-2">
                    <div class="space-y-4 max-w-md mx-auto">
                        <div class="howto-section">Steps</div>
                        <div class="howto-card" style="animation-delay: 0.05s;">
                            <div class="flex items-center justify-between mb-3">
                                <div class="howto-step">Step 1</div>
                                <div class="text-xs text-sky-300 font-semibold uppercase tracking-widest">Watch</div>
                            </div>
                            <div class="flex flex-col sm:flex-row gap-4 items-center">
                                <div class="howto-visual">
                                    <div class="howto-grid" data-howto="watch">
                                        <div class="howto-cell" data-watch-step="1"></div>
                                        <div class="howto-cell" data-watch-step="2"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell" data-watch-step="3"></div>
                                        <div class="howto-cell" data-watch-step="4"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell" data-watch-step="5"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell" data-watch-step="6"></div>
                                        <div class="howto-cell" data-watch-step="7"></div>
                                    </div>
                                </div>
                                <p class="text-sm text-gray-300 leading-relaxed">The path flashes once. Memorize it and get ready to repeat it.</p>
                            </div>
                        </div>
                        <div class="howto-card" style="animation-delay: 0.12s;">
                            <div class="flex items-center justify-between mb-3">
                                <div class="howto-step">Step 2</div>
                                <div class="text-xs text-emerald-300 font-semibold uppercase tracking-widest">Repeat</div>
                            </div>
                            <div class="flex flex-col sm:flex-row gap-4 items-center">
                                <div class="howto-visual">
                                    <div class="howto-grid" data-howto="repeat">
                                        <div class="howto-cell" data-repeat-step="1"></div>
                                        <div class="howto-cell" data-repeat-step="2"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell" data-repeat-step="3"></div>
                                        <div class="howto-cell" data-repeat-step="4"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell" data-repeat-step="5"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell"></div>
                                        <div class="howto-cell" data-repeat-step="6"></div>
                                        <div class="howto-cell" data-repeat-step="7"></div>
                                    </div>
                                </div>
                                <p class="text-sm text-gray-300 leading-relaxed">Tap the same squares in order. A wrong tap costs a heart.</p>
                            </div>
                        </div>
                        <div class="howto-card" style="animation-delay: 0.19s;">
                            <div class="flex items-center justify-between mb-3">
                                <div class="howto-step">Step 3</div>
                                <div class="text-xs text-amber-300 font-semibold uppercase tracking-widest">Survive</div>
                            </div>
                            <div class="flex flex-col sm:flex-row gap-4 items-center">
                                <div class="howto-visual w-full">
                                    <div class="w-full space-y-3">
                                        <div class="howto-timer"><span></span></div>
                                        <div class="flex items-center justify-between text-[11px] uppercase tracking-widest text-gray-400">
                                            <span>Time</span>
                                            <span>Hearts</span>
                                        </div>
                                        <div class="flex items-center justify-between">
                                            <div class="flex-1"></div>
                                            <div class="howto-hearts">
                                                <svg class="howto-heart text-red-500" viewBox="0 0 24 24" aria-hidden="true">
                                                    <path fill="currentColor" d="M12 21s-6.713-4.477-9.6-8.23C.46 10.357.999 7.07 3.044 5.25 4.94 3.57 7.62 3.78 9.272 5.49L12 8.323l2.728-2.834c1.652-1.71 4.333-1.92 6.229-.24 2.045 1.82 2.584 5.107.644 7.52C18.713 16.523 12 21 12 21z"></path>
                                                </svg>
                                                <svg class="howto-heart text-red-500" viewBox="0 0 24 24" aria-hidden="true">
                                                    <path fill="currentColor" d="M12 21s-6.713-4.477-9.6-8.23C.46 10.357.999 7.07 3.044 5.25 4.94 3.57 7.62 3.78 9.272 5.49L12 8.323l2.728-2.834c1.652-1.71 4.333-1.92 6.229-.24 2.045 1.82 2.584 5.107.644 7.52C18.713 16.523 12 21 12 21z"></path>
                                                </svg>
                                                <svg class="howto-heart text-gray-600" viewBox="0 0 24 24" aria-hidden="true">
                                                    <path fill="currentColor" d="M12 21s-6.713-4.477-9.6-8.23C.46 10.357.999 7.07 3.044 5.25 4.94 3.57 7.62 3.78 9.272 5.49L12 8.323l2.728-2.834c1.652-1.71 4.333-1.92 6.229-.24 2.045 1.82 2.584 5.107.644 7.52C18.713 16.523 12 21 12 21z"></path>
                                                </svg>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <p class="text-sm text-gray-300 leading-relaxed">Beat the timer before it drains. Running out of hearts ends the run.</p>
                            </div>
                        </div>
                        <div class="howto-section">Scoring</div>
                        <div class="howto-card" style="animation-delay: 0.26s;">
                            <div class="flex items-center justify-between mb-3">
                                <div class="text-xs text-slate-400 font-semibold uppercase tracking-widest">Score Breakdown Per Level</div>
                                <div class="text-xs text-yellow-300 font-semibold uppercase tracking-widest">Points</div>
                            </div>
                            <div class="space-y-2 text-sm text-gray-300">
                                <div class="howto-score-row">
                                    <div class="flex items-center gap-2">
                                        <span>Completing a Level</span>
                                        <button class="howto-info-btn" type="button" aria-label="Explain points per level" aria-expanded="false" aria-controls="howto-score-info-base" data-score-info>?</button>
                                    </div>
                                    <span id="howto-score-base" class="font-mono text-yellow-300">+0</span>
                                </div>
                                <div id="howto-score-info-base" class="howto-score-info hidden">Flat points for clearing a level, before any bonuses.</div>
                                <div class="howto-score-row">
                                    <div class="flex items-center gap-2">
                                        <span>Time Bonus</span>
                                        <button class="howto-info-btn" type="button" aria-label="Explain time bonus" aria-expanded="false" aria-controls="howto-score-info-time" data-score-info>?</button>
                                    </div>
                                    <span id="howto-score-time" class="font-mono text-yellow-300">+0 ~ +0</span>
                                </div>
                                <div id="howto-score-info-time" class="howto-score-info hidden">Finish faster to push the time bonus toward the max.</div>
                                <div class="howto-score-row">
                                    <div class="flex items-center gap-2">
                                        <span>Stage Bonus</span>
                                        <button class="howto-info-btn" type="button" aria-label="Explain stage bonus" aria-expanded="false" aria-controls="howto-score-info-stage" data-score-info>?</button>
                                    </div>
                                    <span id="howto-score-stage" class="font-mono text-yellow-300">+(stage number Ã— 0)</span>
                                </div>
                                <div id="howto-score-info-stage" class="howto-score-info hidden">Later stages add more bonus points.</div>
                            </div>
                            <div id="howto-score-formula" class="mt-3 text-xs text-gray-400"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- GAME OVER SCREEN -->
            <div id="game-over-screen" class="hidden absolute inset-0 z-30 flex flex-col items-center justify-center p-6 text-center">
                <h2 id="game-over-title" class="text-4xl font-black text-red-500 mb-2">GAME OVER</h2>
                <div id="game-over-mark" class="text-2xl font-semibold text-gray-200 mb-2">Good try!</div>
                <p id="game-over-description" class="text-gray-300 mb-6">You ran out of hearts.</p>
                
                <div class="bg-gray-800 rounded-lg p-6 w-full max-w-xs mb-6 border border-gray-700">
                    <div class="text-xs text-gray-500 uppercase tracking-widest mb-1">Final Score</div>
                    <div id="final-score" class="text-4xl font-bold text-white">0</div>
                </div>

                <div class="space-y-3 w-full max-w-xs">
                    <button id="btn-retry" class="w-full bg-white text-gray-900 hover:bg-gray-100 font-bold py-3 px-4 rounded shadow-lg transform transition active:scale-95">TRY AGAIN</button>
                    <button id="btn-home" class="w-full border border-gray-600 text-gray-400 hover:text-white hover:border-gray-500 font-semibold py-3 px-4 rounded transition">MAIN MENU</button>
                </div>
            </div>

        </main>

        <div id="app-version" class="absolute bottom-2 right-3 text-[10px] text-gray-700 uppercase tracking-widest pointer-events-none"></div>
    </div>

    <!-- AUDIO ELEMENTS (Simple synthesizers used in JS, fallback placeholders here) -->

    <script>
        /**
         * CONFIGURATION
         */
        const APP_VERSION = 'v1.0.16';

        const CONFIG = {
            stages: [
                { id: 1, size: 3, levels: 1 },
                { id: 2, size: 4, levels: 2 },
                { id: 3, size: 5, levels: 3 },
                { id: 4, size: 6, levels: 5 },
                { id: 5, size: 7, levels: 8 },
                { id: 6, size: 8, levels: 13 },
            ],
            initialHearts: 3,
            baseScorePerLevel: 10,
            scoring: {
                timeBonusMultiplier: 5,
                stageBonusMultiplier: 5
            },
            playback: {
                speedBaseMs: 300, // ms per square
                speedMinMs: 75,  // Cap for speed
                speedDecrementPerStageMs: 50, // ms decrease per stage
                startDelayMs: 800, // Delay before playback starts
                gapRatio: 0.5, // Gap between tones as ratio of tone duration
                toneBaseHz: 300, // Starting tone frequency
                toneStepHz: 50, // Frequency increase per square
                toneDurationSec: 0.1 // Tone duration in seconds
            },
            input: {
                timePerSquareBaseSec: 1.5, // Seconds per square for input
                timePerSquareMinSec: 0.5,  // Cap for time per square
                timePerSquareStagePenaltySec: 0.3, // Seconds reduced per stage
                tickRateMs: 50,
                lowTimeThresholdPct: 30,
                successClearMs: 200,
                errorClearMs: 400,
                retryDelayMs: 300,
                correctToneBaseHz: 400,
                correctToneStepHz: 50,
                correctToneDurationSec: 0.1,
                wrongToneHz: 150,
                wrongToneDurationSec: 0.3,
                timeUpToneHz: 100,
                timeUpToneDurationSec: 0.5
            },
            reveal: {
                mistakeMs: 2500
            },
            levelTransition: {
                breakdownMs: 2000,
                levelIntroMs: 900
            },
            path: {
                minTurnsAtLevelZero: 0, // Initial min turns
                minTurnsPerLevelOffset: 1, // Increases min turns as levels progress
                lengthBase: 4, // Base path length
                lengthSizeDivisor: 2, // Larger grids yield longer paths
                attemptLimit: 50, // Max attempts to generate a valid path
                fallbackMinLength: 3, // Fallback path length if no valid path found
                fallbackMaxLength: 4, // Fallback path length if no valid path found
                fallbackRow: 0 // Fallback row to start from if no valid path found
            },
            audio: {
                gainStart: 0.1,
                gainEnd: 0.01,
                successToneFreqsHz: [800, 1200],
                successToneDelayMs: 100,
                successToneDurationSec: 0.1,
                stageIntroToneType: 'sine',
                stageIntroToneFreqsHz: [420, 520],
                stageIntroToneDelayMs: 140,
                stageIntroToneDurationSec: 0.12,
                gameOverToneType: 'sawtooth',
                gameOverToneFreqsHz: [200, 140],
                gameOverToneDelayMs: 120,
                gameOverToneDurationSec: 0.25,
                victoryToneType: 'triangle',
                victoryToneFreqsHz: [523, 659, 784],
                victoryToneDelayMs: 120,
                victoryToneDurationSec: 0.15
            },
            ui: {
                heartFontSizeRem: 1.25
            },
            leaderboard: {
                maxEntries: 50,
                highlightTopCount: 3,
                topRankIcons: ['ðŸ‘‘', 'ðŸ¥ˆ', 'ðŸ¥‰']
            },
            timing: {
                msPerSecond: 1000
            },
            stageDifficulty: [
                'Very Easy',
                'Easy',
                'Normal',
                'Medium',
                'Hard',
                'Impossible!',
            ],
            gameOverMessages: [
                'Good try!',
                'So close!',
                'Nice effort!',
                'Not bad!',
                'That was good!'
            ],
            localStorageKey: 'ftp_leaderboard_v1'
        };

        /**
         * STATE MANAGEMENT
         */
        const state = {
            status: 'MENU', // MENU, WATCH, INPUT, SUCCESS, FAIL, GAMEOVER
            player: {
                name: 'Player',
                score: 0,
                hearts: CONFIG.initialHearts,
                stageIndex: 0,
                levelIndex: 0 // 0-based, so 0 is Level 1
            },
            grid: [],
            path: [], // Array of {r, c}
            inputIndex: 0,
            timer: null,
            timerValue: 0,
            maxTime: 0
        };

        const howtoTimers = {
            watch: null,
            repeat: null
        };

        const levelTransitionTimers = {
            breakdown: null,
            levelIntro: null
        };

        // DOM Elements
        const screens = {
            menu: document.getElementById('menu-screen'),
            stage: document.getElementById('stage-screen'),
            game: document.getElementById('game-container'),
            leaderboard: document.getElementById('leaderboard-screen'),
            howto: document.getElementById('howto-screen'),
            gameOver: document.getElementById('game-over-screen')
        };
        
        const ui = {
            header: document.getElementById('hud-header'),
            hud: document.getElementById('game-hud'),
            stageInfo: document.getElementById('stage-info'),
            scoreDisplay: document.getElementById('score-display'),
            highScoreMini: document.getElementById('high-score-mini'),
            heartsContainer: document.getElementById('hearts-container'),
            statusText: document.getElementById('status-text'),
            timerBar: document.getElementById('timer-bar'),
            grid: document.getElementById('grid'),
            overlay: document.getElementById('overlay-message'),
            overlayTitle: document.getElementById('overlay-title'),
            overlayBreakdown: document.getElementById('overlay-breakdown'),
            overlaySubtitle: document.getElementById('overlay-subtitle'),
            overlayBaseScore: document.getElementById('overlay-score-base'),
            overlayTimeBonus: document.getElementById('overlay-score-time'),
            overlayStageBonus: document.getElementById('overlay-score-stage'),
            overlayTotalScore: document.getElementById('overlay-score-total'),
            btnNext: document.getElementById('btn-next-level'),
            pathOverlay: document.getElementById('path-overlay'),
            pathLine: document.getElementById('path-line'),
            stageTitle: document.getElementById('stage-title'),
            stageLevelCount: document.getElementById('stage-level-count'),
            stageDifficulty: document.getElementById('stage-difficulty'),
            playerNameInput: document.getElementById('player-name'),
            finalScore: document.getElementById('final-score'),
            leaderboardBody: document.getElementById('leaderboard-body'),
            gameOverTitle: document.getElementById('game-over-title'),
            gameOverMark: document.getElementById('game-over-mark'),
            gameOverDescription: document.getElementById('game-over-description')
        };
        const GAME_OVER_TITLE_CLASS = 'text-4xl font-black text-red-500 mb-2';
        const VICTORY_TITLE_CLASS = 'text-4xl font-black text-green-500 mb-2';
        const GAME_OVER_MARK_CLASS = 'text-2xl font-semibold text-gray-200 mb-2';
        const VICTORY_MARK_CLASS = 'text-6xl mb-2';

        /**
         * PATH GENERATION ALGORITHM
         */
        const PathGenerator = {
            generate(size, levelIndex) {
                // Determine complexity based on levelIndex and CONFIG.path tuning.
                const minTurns = levelIndex === 0
                    ? CONFIG.path.minTurnsAtLevelZero
                    : levelIndex + CONFIG.path.minTurnsPerLevelOffset;
                const length = Math.min(
                    size * size,
                    CONFIG.path.lengthBase + levelIndex + Math.floor(size / CONFIG.path.lengthSizeDivisor)
                );

                let bestPath = [];

                // Try multiple times to find a valid path that meets criteria
                for(let attempt = 0; attempt < CONFIG.path.attemptLimit; attempt++) {
                    const startR = Math.floor(Math.random() * size);
                    const startC = Math.floor(Math.random() * size);
                    
                    const path = this.walk(size, startR, startC, length, minTurns);
                    if (path && path.length >= length) {
                        bestPath = path;
                        break;
                    }
                    // Fallback to any valid path found if loop nears end
                    if (path && path.length > bestPath.length) bestPath = path;
                }
                
                // If backtracking failed to make a long enough path, just make a simple one
                if (bestPath.length < CONFIG.path.fallbackMinLength) {
                     // Fallback simple line generator
                     bestPath = [];
                     for(let i=0; i<Math.min(size, CONFIG.path.fallbackMaxLength); i++) {
                         bestPath.push({r: CONFIG.path.fallbackRow, c: i});
                     }
                }

                return bestPath;
            },

            walk(size, r, c, targetLength, minTurns) {
                const stack = [{ r, c, path: [{r,c}], turns: 0, lastDir: null }];
                
                // DFS for path generation
                // Note: Iterative DFS to avoid stack overflow, though recursion is fine for the configured grid sizes
                // Using a simplified randomized DFS
                
                return this.recursiveWalk(size, r, c, [], null, 0, targetLength, minTurns);
            },

            recursiveWalk(size, r, c, currentPath, lastDir, currentTurns, targetLen, minTurns) {
                const newPath = [...currentPath, {r, c}];
                
                if (newPath.length === targetLen) {
                    return (currentTurns >= minTurns) ? newPath : null;
                }

                const directions = [
                    {dr: -1, dc: 0}, // Up
                    {dr: 1, dc: 0},  // Down
                    {dr: 0, dc: -1}, // Left
                    {dr: 0, dc: 1}   // Right
                ];

                // Shuffle directions for randomness
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }

                for (let dir of directions) {
                    const nr = r + dir.dr;
                    const nc = c + dir.dc;

                    // Check bounds
                    if (nr >= 0 && nr < size && nc >= 0 && nc < size) {
                        // Check not visited
                        if (!newPath.some(p => p.r === nr && p.c === nc)) {
                            
                            // Check turns
                            let newTurns = currentTurns;
                            if (lastDir && (lastDir.dr !== dir.dr || lastDir.dc !== dir.dc)) {
                                newTurns++;
                            }

                            const result = this.recursiveWalk(size, nr, nc, newPath, dir, newTurns, targetLen, minTurns);
                            if (result) return result;
                        }
                    }
                }
                return null;
            }
        };

        /**
         * AMBIENT PATHS
         */
        const AMBIENT_PATHS = {
            minPaths: 3,
            maxPaths: 6,
            minLength: 10,
            maxLength: 22,
            minStartDistance: 4,
            pauseSec: 2.4
        };

        let ambientResizeTimer = null;
        let ambientRefreshTimer = null;

        function setupAmbientPaths() {
            const container = document.getElementById('ambient-paths');
            if (!container) return;

            const style = getComputedStyle(document.body);
            const gridSize = parseFloat(style.getPropertyValue('--grid-size')) || 48;
            const stepSec = parseCssTime(style.getPropertyValue('--ambient-step'), 0.8);
            const baseDuration = parseCssTime(style.getPropertyValue('--ambient-duration'), 20);

            const cols = Math.max(8, Math.floor(window.innerWidth / gridSize));
            const rows = Math.max(10, Math.floor(window.innerHeight / gridSize));
            const area = cols * rows;
            const pathCount = clamp(Math.round(area / 60), AMBIENT_PATHS.minPaths, AMBIENT_PATHS.maxPaths);

            container.innerHTML = '';

            let maxDuration = 0;
            let maxDelay = 0;
            const starts = [];
            for (let i = 0; i < pathCount; i++) {
                starts.push(pickAmbientStart(cols, rows, starts, AMBIENT_PATHS.minStartDistance));
            }

            starts.forEach(start => {
                const length = clamp(
                    getRandomInt(AMBIENT_PATHS.minLength, AMBIENT_PATHS.maxLength),
                    6,
                    cols * rows
                );
                const step = stepSec * (0.8 + Math.random() * 0.45);
                const duration = Math.max(baseDuration, (length * step) + AMBIENT_PATHS.pauseSec);
                const delay = Math.random() * 3;
                const path = buildAmbientPath(cols, rows, length, start);

                maxDuration = Math.max(maxDuration, duration);
                maxDelay = Math.max(maxDelay, delay);

                path.forEach((point, index) => {
                    const square = document.createElement('span');
                    square.className = 'ambient-square';
                    square.style.setProperty('--x', point.x);
                    square.style.setProperty('--y', point.y);
                    square.style.setProperty('--order', index);
                    square.style.setProperty('--duration', `${duration.toFixed(2)}s`);
                    square.style.setProperty('--delay', `${delay.toFixed(2)}s`);
                    container.appendChild(square);
                });
            });

            if (ambientRefreshTimer) clearTimeout(ambientRefreshTimer);
            const refreshMs = Math.max(12000, Math.ceil((maxDuration + maxDelay + 1) * 1000));
            ambientRefreshTimer = setTimeout(setupAmbientPaths, refreshMs);
        }

        function buildAmbientPath(cols, rows, length, start) {
            const path = [start];
            const used = new Set([coordKey(start)]);
            let current = start;
            let prev = null;

            for (let i = 1; i < length; i++) {
                const neighbors = [
                    { x: current.x + 1, y: current.y },
                    { x: current.x - 1, y: current.y },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x, y: current.y - 1 }
                ].filter(point => point.x >= 0 && point.x < cols && point.y >= 0 && point.y < rows);

                let options = neighbors;
                if (prev) {
                    options = options.filter(point => point.x !== prev.x || point.y !== prev.y);
                }
                const fresh = options.filter(point => !used.has(coordKey(point)));
                if (fresh.length) options = fresh;
                if (!options.length) options = neighbors;

                const next = options[Math.floor(Math.random() * options.length)];
                path.push(next);
                used.add(coordKey(next));
                prev = current;
                current = next;
            }

            return path;
        }

        function pickAmbientStart(cols, rows, starts, minDistance) {
            for (let attempt = 0; attempt < 40; attempt++) {
                const candidate = { x: getRandomInt(0, cols - 1), y: getRandomInt(0, rows - 1) };
                const isFar = starts.every(start =>
                    Math.abs(start.x - candidate.x) + Math.abs(start.y - candidate.y) >= minDistance
                );
                if (isFar) return candidate;
            }
            return { x: getRandomInt(0, cols - 1), y: getRandomInt(0, rows - 1) };
        }

        function parseCssTime(value, fallbackSec) {
            const raw = String(value || '').trim();
            const num = parseFloat(raw);
            if (!Number.isFinite(num)) return fallbackSec;
            return raw.endsWith('ms') ? num / 1000 : num;
        }

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function coordKey(point) {
            return `${point.x},${point.y}`;
        }

        function clamp(value, min, max) {
            return Math.min(max, Math.max(min, value));
        }

        /**
         * GAME LOGIC
         */
        function init() {
            const appVersionEl = document.getElementById('app-version');
            if (appVersionEl) appVersionEl.textContent = APP_VERSION;

            setupAmbientPaths();
            window.addEventListener('resize', () => {
                if (ambientResizeTimer) clearTimeout(ambientResizeTimer);
                ambientResizeTimer = setTimeout(setupAmbientPaths, 150);
            });

            // Load High Score
            updateMiniHighScore();
            
            // Event Listeners
            document.getElementById('btn-start').addEventListener('click', startGame);
            document.getElementById('btn-howto').addEventListener('click', showHowTo);
            document.getElementById('btn-leaderboard').addEventListener('click', showLeaderboard);
            document.getElementById('btn-close-leaderboard').addEventListener('click', hideLeaderboard);
            document.getElementById('btn-close-howto').addEventListener('click', hideHowTo);
            document.getElementById('btn-reset-data').addEventListener('click', resetData);
            document.getElementById('btn-next-level').addEventListener('click', nextLevel);
            document.getElementById('btn-stage-start').addEventListener('click', startStage);
            document.getElementById('btn-retry').addEventListener('click', restartGame);
            document.getElementById('btn-home').addEventListener('click', goHome);

            initHowToAnimations();
            updateHowToScoreDetails();
            initHowToScoreToggles();
        }

        function startGame() {
            clearLevelTransitionTimers();
            const name = ui.playerNameInput.value.trim() || "Player";
            state.player.name = name;
            state.player.score = 0;
            state.player.hearts = CONFIG.initialHearts;
            state.player.stageIndex = 0;
            state.player.levelIndex = 0;
            
            showStageIntro();
        }

        function restartGame() {
            startGame();
        }

        function goHome() {
            clearLevelTransitionTimers();
            showScreen('menu');
            ui.hud.classList.add('hidden');
            ui.stageInfo.classList.add('hidden');
            ui.scoreDisplay.classList.add('hidden');
            ui.highScoreMini.classList.add('hidden');
        }

        function showHowTo() {
            showScreen('howto');
        }

        function hideHowTo() {
            showScreen('menu');
        }

        function initHowToAnimations() {
            const watchCells = Array.from(document.querySelectorAll('[data-watch-step]'))
                .sort((a, b) => Number(a.dataset.watchStep) - Number(b.dataset.watchStep));
            const repeatCells = Array.from(document.querySelectorAll('[data-repeat-step]'))
                .sort((a, b) => Number(a.dataset.repeatStep) - Number(b.dataset.repeatStep));

            if (!watchCells.length || !repeatCells.length) return;

            const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            if (prefersReducedMotion) {
                watchCells.forEach(cell => cell.classList.add('is-watch'));
                repeatCells.forEach(cell => cell.classList.add('is-repeat'));
                return;
            }

            if (howtoTimers.watch) clearTimeout(howtoTimers.watch);
            if (howtoTimers.repeat) clearTimeout(howtoTimers.repeat);

            const watchStepMs = 350;
            const watchPulseMs = 220;
            const watchPauseMs = 450;

            const runWatch = () => {
                watchCells.forEach((cell, index) => {
                    setTimeout(() => {
                        cell.classList.add('is-watch');
                        setTimeout(() => cell.classList.remove('is-watch'), watchPulseMs);
                    }, index * watchStepMs);
                });

                const totalMs = ((watchCells.length - 1) * watchStepMs) + watchPulseMs + watchPauseMs;
                howtoTimers.watch = setTimeout(runWatch, totalMs);
            };

            const repeatStepMs = 350;
            const repeatHoldMs = 650;
            const repeatResetMs = 450;

            const runRepeat = () => {
                repeatCells.forEach((cell, index) => {
                    setTimeout(() => {
                        cell.classList.add('is-repeat');
                    }, index * repeatStepMs);
                });

                const clearAtMs = ((repeatCells.length - 1) * repeatStepMs) + repeatHoldMs;
                setTimeout(() => {
                    repeatCells.forEach(cell => cell.classList.remove('is-repeat'));
                }, clearAtMs);

                howtoTimers.repeat = setTimeout(runRepeat, clearAtMs + repeatResetMs);
            };

            runWatch();
            runRepeat();
        }

        function updateHowToScoreDetails() {
            const baseEl = document.getElementById('howto-score-base');
            const timeEl = document.getElementById('howto-score-time');
            const stageEl = document.getElementById('howto-score-stage');
            const formulaEl = document.getElementById('howto-score-formula');

            if (!baseEl || !timeEl || !stageEl || !formulaEl) return;

            const baseScore = CONFIG.baseScorePerLevel;
            const timeBonusMax = CONFIG.scoring.timeBonusMultiplier;
            const stageBonusStep = CONFIG.scoring.stageBonusMultiplier;

            baseEl.textContent = `+${baseScore}`;
            timeEl.textContent = `+1 ~ +${timeBonusMax}`;
            stageEl.textContent = `+(stage number Ã— ${stageBonusStep})`;
            formulaEl.textContent = `Score per level = flat points + time bonus + stage bonus`;
        }

        function initHowToScoreToggles() {
            const infoButtons = Array.from(document.querySelectorAll('[data-score-info]'));
            if (!infoButtons.length) return;

            infoButtons.forEach((button) => {
                button.addEventListener('click', () => {
                    const panelId = button.getAttribute('aria-controls');
                    if (!panelId) return;
                    const panel = document.getElementById(panelId);
                    if (!panel) return;

                    const willOpen = panel.classList.contains('hidden');
                    panel.classList.toggle('hidden');
                    button.setAttribute('aria-expanded', String(willOpen));
                });
            });
        }

        function showStageIntro() {
            const stageConfig = CONFIG.stages[state.player.stageIndex];
            const stageNumber = state.player.stageIndex + 1;
            const difficulty = CONFIG.stageDifficulty[state.player.stageIndex] || 'Unknown';

            ui.hud.classList.add('hidden');
            ui.stageInfo.classList.add('hidden');
            ui.scoreDisplay.classList.add('hidden');
            ui.highScoreMini.classList.add('hidden');
            updateHUD();
            ui.stageTitle.textContent = `STAGE ${stageNumber}`;
            ui.stageLevelCount.textContent = stageConfig.levels;
            ui.stageDifficulty.textContent = difficulty;
            showScreen('stage');
            playToneSequence(
                CONFIG.audio.stageIntroToneFreqsHz,
                CONFIG.audio.stageIntroToneType,
                CONFIG.audio.stageIntroToneDurationSec,
                CONFIG.audio.stageIntroToneDelayMs
            );
        }

        function startStage() {
            clearLevelTransitionTimers();
            ui.hud.classList.remove('hidden');
            ui.stageInfo.classList.remove('hidden');
            ui.scoreDisplay.classList.remove('hidden');
            ui.highScoreMini.classList.remove('hidden');
            showScreen('game');
            setupLevel({ reusePath: false, hideOverlay: false });
            showLevelIntro(() => {
                queuePlayback();
            });
        }

        function updateHUD() {
            const stageData = CONFIG.stages[state.player.stageIndex];
            ui.stageInfo.textContent = `STAGE ${state.player.stageIndex + 1} - LVL ${state.player.levelIndex + 1}`;
            ui.scoreDisplay.textContent = state.player.score;
            
            // Render Hearts
            ui.heartsContainer.innerHTML = '';
            for (let i = 0; i < CONFIG.initialHearts; i++) {
                const heart = document.createElement('span');
                heart.innerHTML = `
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                        <path fill="currentColor" d="M12 21s-6.713-4.477-9.6-8.23C.46 10.357.999 7.07 3.044 5.25 4.94 3.57 7.62 3.78 9.272 5.49L12 8.323l2.728-2.834c1.652-1.71 4.333-1.92 6.229-.24 2.045 1.82 2.584 5.107.644 7.52C18.713 16.523 12 21 12 21z"></path>
                    </svg>
                `;
                heart.className = i < state.player.hearts
                    ? 'heart-icon text-red-500 animate-pulse'
                    : 'heart-icon text-gray-700';
                heart.style.fontSize = `${CONFIG.ui.heartFontSizeRem}rem`;
                ui.heartsContainer.appendChild(heart);
            }
        }

        function clearLevelTransitionTimers() {
            if (levelTransitionTimers.breakdown) {
                clearTimeout(levelTransitionTimers.breakdown);
                levelTransitionTimers.breakdown = null;
            }
            if (levelTransitionTimers.levelIntro) {
                clearTimeout(levelTransitionTimers.levelIntro);
                levelTransitionTimers.levelIntro = null;
            }
        }

        function scheduleLevelTransition() {
            clearLevelTransitionTimers();
            ui.btnNext.classList.add('hidden');
            ui.overlayBreakdown.classList.remove('hidden');

            const stageConfig = CONFIG.stages[state.player.stageIndex];
            const hasNextLevelInStage = (state.player.levelIndex + 1) < stageConfig.levels;
            const breakdownMs = CONFIG.levelTransition.breakdownMs;

            levelTransitionTimers.breakdown = setTimeout(() => {
                if (!hasNextLevelInStage) {
                    ui.overlay.classList.add('hidden');
                    nextLevel();
                    return;
                }

                state.player.levelIndex++;
                updateHUD();
                setupLevel({ reusePath: false, hideOverlay: false });
                showLevelIntro(() => {
                    queuePlayback();
                });
            }, breakdownMs);
        }

        function showLevelIntro(onDone) {
            clearLevelTransitionTimers();
            ui.btnNext.classList.add('hidden');
            ui.overlayBreakdown.classList.add('hidden');
            ui.overlayTitle.textContent = `LEVEL ${state.player.levelIndex + 1}`;
            ui.overlay.classList.remove('hidden');

            levelTransitionTimers.levelIntro = setTimeout(() => {
                ui.overlay.classList.add('hidden');
                if (typeof onDone === 'function') {
                    onDone();
                }
            }, CONFIG.levelTransition.levelIntroMs);
        }

        function setupLevel({ reusePath = false, hideOverlay = true } = {}) {
            if (hideOverlay) {
                ui.overlay.classList.add('hidden');
            }
            ui.pathOverlay.classList.add('hidden');
            state.status = 'WATCH';
            state.inputIndex = 0;
            ui.statusText.textContent = "WATCH";
            ui.statusText.className = "text-sm font-semibold text-blue-300 uppercase tracking-wider";
            ui.timerBar.style.width = '100%';
            ui.timerBar.className = 'h-full bg-blue-500 w-full';

            const stageConfig = CONFIG.stages[state.player.stageIndex];
            
            // 1. Generate Grid
            renderGrid(stageConfig.size);
            setGridInteractivity(false);

            // 2. Generate Path (unless reusing after a mistake)
            if (!reusePath || !Array.isArray(state.path) || state.path.length === 0) {
                state.path = PathGenerator.generate(stageConfig.size, state.player.levelIndex);
            }
        }

        function clearLevelGrid() {
            setGridInteractivity(false);
            ui.pathOverlay.classList.add('hidden');
            ui.grid.classList.add('grid-no-transitions');
            void ui.grid.offsetHeight;
            state.grid.forEach(({ el }) => {
                el.classList.remove('active', 'error', 'reveal', 'success', 'correct');
                el.style.pointerEvents = '';
            });
            requestAnimationFrame(() => {
                ui.grid.classList.remove('grid-no-transitions');
            });
        }

        function queuePlayback() {
            setTimeout(() => playSequence(), CONFIG.playback.startDelayMs);
        }

        function startLevel({ reusePath = false } = {}) {
            clearLevelTransitionTimers();
            setupLevel({ reusePath });
            queuePlayback();
        }

        function renderGrid(size) {
            ui.grid.innerHTML = '';
            ui.grid.style.width = '';
            ui.grid.style.height = '';
            ui.grid.style.gridTemplateColumns = `repeat(${size}, minmax(0, 1fr))`;
            ui.grid.style.gridTemplateRows = `repeat(${size}, minmax(0, 1fr))`;
            
            state.grid = [];
            for(let r=0; r<size; r++) {
                for(let c=0; c<size; c++) {
                    const cell = document.createElement('div');
                    // touch-none added to prevent scrolling interference
                    cell.className = "cell box-border w-full h-full bg-gray-700 rounded-md cursor-pointer hover:bg-gray-600 border border-gray-600 touch-none";
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    
                    // Unified Pointer Event Handler (Handles Touch and Mouse)
                    cell.addEventListener('pointerdown', (e) => {
                         e.preventDefault(); 
                         handleInput(r, c, cell);
                    });
                    
                    ui.grid.appendChild(cell);
                    state.grid.push({r, c, el: cell});
                }
            }

            requestAnimationFrame(() => fitGridToPixels(size));
        }

        function getCell(r, c) {
            return state.grid.find(item => item.r === r && item.c === c)?.el;
        }

        function fitGridToPixels(size) {
            const gridRect = ui.grid.getBoundingClientRect();
            if (!gridRect.width || !gridRect.height) return;

            const styles = window.getComputedStyle(ui.grid);
            const gapXRaw = parseFloat(styles.columnGap || styles.gap || 0);
            const gapYRaw = parseFloat(styles.rowGap || styles.gap || 0);
            const gapX = Number.isFinite(gapXRaw) ? gapXRaw : 0;
            const gapY = Number.isFinite(gapYRaw) ? gapYRaw : 0;
            const totalGapX = gapX * (size - 1);
            const totalGapY = gapY * (size - 1);

            const maxCellWidth = (gridRect.width - totalGapX) / size;
            const maxCellHeight = (gridRect.height - totalGapY) / size;
            let cellSize = Math.round(Math.min(maxCellWidth, maxCellHeight));

            if (!cellSize || cellSize <= 0) return;

            let gridWidth = (cellSize * size) + totalGapX;
            let gridHeight = (cellSize * size) + totalGapY;

            if (gridWidth > gridRect.width || gridHeight > gridRect.height) {
                cellSize = Math.floor(Math.min(maxCellWidth, maxCellHeight));
                gridWidth = (cellSize * size) + totalGapX;
                gridHeight = (cellSize * size) + totalGapY;
            }

            ui.grid.style.width = `${gridWidth}px`;
            ui.grid.style.height = `${gridHeight}px`;
            ui.grid.style.gridTemplateColumns = `repeat(${size}, ${cellSize}px)`;
            ui.grid.style.gridTemplateRows = `repeat(${size}, ${cellSize}px)`;
        }

        function setGridInteractivity(enabled) {
            ui.grid.classList.toggle('grid-locked', !enabled);
        }

        async function playSequence() {
            // Speed Calculation: Faster as stages progress
            const speed = Math.max(
                CONFIG.playback.speedMinMs,
                CONFIG.playback.speedBaseMs - (state.player.stageIndex * CONFIG.playback.speedDecrementPerStageMs)
            );
            
            for (let i = 0; i < state.path.length; i++) {
                const {r, c} = state.path[i];
                const el = getCell(r, c);
                
                // Highlight
                el.classList.add('active');
                playTone(
                    CONFIG.playback.toneBaseHz + (i * CONFIG.playback.toneStepHz),
                    'sine',
                    CONFIG.playback.toneDurationSec
                ); // Audio feedback
                
                await new Promise(res => setTimeout(res, speed));
                
                // Unhighlight (keep a small gap if it's the same cell - though path gen usually moves)
                el.classList.remove('active');
                await new Promise(res => setTimeout(res, speed * CONFIG.playback.gapRatio));
            }

            beginInputPhase();
        }

        function updateRevealPathLine(startIndex) {
            const gridRect = ui.grid.getBoundingClientRect();
            const containerRect = screens.game.getBoundingClientRect();

            if (!gridRect.width || !gridRect.height) return false;

            const left = gridRect.left - containerRect.left;
            const top = gridRect.top - containerRect.top;

            ui.pathOverlay.style.left = `${left}px`;
            ui.pathOverlay.style.top = `${top}px`;
            ui.pathOverlay.style.width = `${gridRect.width}px`;
            ui.pathOverlay.style.height = `${gridRect.height}px`;
            ui.pathOverlay.setAttribute('viewBox', `0 0 ${gridRect.width} ${gridRect.height}`);

            const segment = state.path.slice(startIndex);
            const points = segment.map(({r, c}) => {
                const el = getCell(r, c);
                if (!el) return null;
                const rect = el.getBoundingClientRect();
                return {
                    x: rect.left - gridRect.left + rect.width / 2,
                    y: rect.top - gridRect.top + rect.height / 2
                };
            }).filter(Boolean);

            if (points.length < 2) return false;

            let d = `M ${points[0].x} ${points[0].y}`;
            for (let i = 1; i < points.length; i++) {
                d += ` L ${points[i].x} ${points[i].y}`;
            }
            ui.pathLine.setAttribute('d', d);

            const length = ui.pathLine.getTotalLength();
            ui.pathLine.dataset.length = length;
            ui.pathLine.style.strokeDasharray = length;
            ui.pathLine.style.strokeDashoffset = length;
            return true;
        }

        function revealPathBriefly(startIndex, onDone) {
            const start = Math.max(0, startIndex || 0);
            const hasLine = updateRevealPathLine(start);
            const completedCells = state.path.slice(0, start).map(({r, c}) => getCell(r, c)).filter(Boolean);
            setGridInteractivity(false);

            if (hasLine) {
                ui.pathLine.style.transition = 'none';
                void ui.pathLine.getBoundingClientRect();
                ui.pathOverlay.classList.remove('hidden');
                ui.pathLine.style.transition = `stroke-dashoffset ${CONFIG.reveal.mistakeMs}ms ease-out`;
                ui.pathLine.style.strokeDashoffset = '0';
            }

            state.path.slice(start).forEach(({r, c}) => {
                const el = getCell(r, c);
                if (!el) return;
                el.classList.add('reveal');
            });

            setTimeout(() => {
                state.path.slice(start).forEach(({r, c}) => {
                    const el = getCell(r, c);
                    if (!el) return;
                    el.classList.remove('reveal');
                });
                completedCells.forEach((el) => {
                    el.classList.remove('correct');
                    el.style.pointerEvents = '';
                });
                if (hasLine) {
                    const length = Number(ui.pathLine.dataset.length || 0);
                    ui.pathLine.style.transition = 'none';
                    ui.pathLine.style.strokeDashoffset = length;
                    ui.pathOverlay.classList.add('hidden');
                }
                setGridInteractivity(true);
                if (typeof onDone === 'function') {
                    onDone();
                }
            }, CONFIG.reveal.mistakeMs);
        }

        function beginInputPhase() {
            state.status = 'INPUT';
            ui.statusText.textContent = "YOUR TURN";
            ui.statusText.className = "text-sm font-bold text-green-400 uppercase tracking-wider animate-pulse";
            ui.timerBar.className = 'h-full bg-green-500 w-full';
            setGridInteractivity(true);

            // Timer Setup
            // Time depends on path length + complexity
            const timePerSquare = Math.max(
                CONFIG.input.timePerSquareMinSec,
                CONFIG.input.timePerSquareBaseSec - (state.player.stageIndex * CONFIG.input.timePerSquareStagePenaltySec)
            );
            state.maxTime = state.path.length * timePerSquare * CONFIG.timing.msPerSecond;
            state.timerValue = state.maxTime;
            
            if (state.timer) clearInterval(state.timer);
            
            const tickRate = CONFIG.input.tickRateMs;
            state.timer = setInterval(() => {
                state.timerValue -= tickRate;
                const pct = (state.timerValue / state.maxTime) * 100;
                ui.timerBar.style.width = `${pct}%`;

                // Change color if low
                if (pct < CONFIG.input.lowTimeThresholdPct) ui.timerBar.className = 'h-full bg-red-500 w-full';

                if (state.timerValue <= 0) {
                    handleMistake("TIME UP");
                }
            }, tickRate);
        }

        function handleInput(r, c, el) {
            if (state.status !== 'INPUT') return;

            const target = state.path[state.inputIndex];

            // Feedback Animation
            el.classList.remove('active');
            void el.offsetWidth; // trigger reflow

            if (r === target.r && c === target.c) {
                // Correct
                el.classList.add('success');
                el.classList.add('correct');
                el.style.pointerEvents = 'none';
                playTone(
                    CONFIG.input.correctToneBaseHz + (state.inputIndex * CONFIG.input.correctToneStepHz),
                    'triangle',
                    CONFIG.input.correctToneDurationSec
                );
                
                setTimeout(() => el.classList.remove('success'), CONFIG.input.successClearMs);
                
                state.inputIndex++;

                if (state.inputIndex >= state.path.length) {
                    completeLevel();
                }
            } else {
                // Wrong
                el.classList.add('error');
                playTone(CONFIG.input.wrongToneHz, 'sawtooth', CONFIG.input.wrongToneDurationSec);
                setTimeout(() => el.classList.remove('error'), CONFIG.input.errorClearMs);
                handleMistake("WRONG");
            }
        }

        function handleMistake(reason) {
            clearInterval(state.timer);

            // Add sound for Time Up
            if (reason === "TIME UP") {
                playTone(CONFIG.input.timeUpToneHz, 'sawtooth', CONFIG.input.timeUpToneDurationSec);
            }

            state.status = 'FAIL';
            
            state.player.hearts--;
            updateHUD();

            ui.statusText.textContent = "PATH";
            ui.statusText.className = "text-sm font-bold text-yellow-300 uppercase tracking-wider";

            revealPathBriefly(state.inputIndex, () => {
                if (state.player.hearts <= 0) {
                    gameOver();
                    return;
                }

                // Brief pause then replay pattern
                ui.statusText.textContent = "TRY AGAIN";
                ui.statusText.className = "text-sm font-bold text-red-500 uppercase tracking-wider";
                setTimeout(() => {
                    startLevel({ reusePath: true });
                }, CONFIG.input.retryDelayMs);
            });
        }

        function completeLevel() {
            clearInterval(state.timer);
            state.status = 'SUCCESS';
            
            // Calculate Score
            // Score = base + time bonus + stage bonus (using CONFIG.scoring multipliers)
            const baseScore = CONFIG.baseScorePerLevel;
            const timeBonus = 1 + Math.floor((state.timerValue / state.maxTime) * CONFIG.scoring.timeBonusMultiplier);
            const stageBonus = (state.player.stageIndex + 1) * CONFIG.scoring.stageBonusMultiplier;
            const levelScore = baseScore + timeBonus + stageBonus;
            state.player.score += levelScore;
            
            updateHUD();
            clearLevelGrid();

            // Show Overlay
            ui.overlayTitle.textContent = "LEVEL COMPLETE";
            ui.overlayBaseScore.textContent = `+${baseScore}`;
            ui.overlayTimeBonus.textContent = `+${timeBonus}`;
            ui.overlayStageBonus.textContent = `+${stageBonus}`;
            ui.overlayTotalScore.textContent = `+${levelScore}`;
            ui.btnNext.textContent = "NEXT LEVEL";
            ui.overlay.classList.remove('hidden');
            ui.overlayBreakdown.classList.remove('hidden');

            if (CONFIG.audio.successToneFreqsHz.length > 0) {
                playTone(CONFIG.audio.successToneFreqsHz[0], 'sine', CONFIG.audio.successToneDurationSec);
            }
            if (CONFIG.audio.successToneFreqsHz.length > 1) {
                setTimeout(() => {
                    playTone(CONFIG.audio.successToneFreqsHz[1], 'sine', CONFIG.audio.successToneDurationSec);
                }, CONFIG.audio.successToneDelayMs);
            }

            scheduleLevelTransition();
        }

        function nextLevel() {
            clearLevelTransitionTimers();
            ui.overlay.classList.add('hidden');
            state.player.levelIndex++;
            
            // Check for Stage Progression
            if (state.player.levelIndex >= CONFIG.stages[state.player.stageIndex].levels) {
                state.player.stageIndex++;
                state.player.levelIndex = 0;
                
                // Check for Game Completion
                if (state.player.stageIndex >= CONFIG.stages.length) {
                    victory();
                    return;
                }

                showStageIntro();
                return;
            }

            updateHUD(); 
            startLevel();
        }

        function gameOver() {
            state.status = 'GAMEOVER';
            saveScore(state.player.name, state.player.score, state.player.stageIndex, state.player.levelIndex);
            
            ui.finalScore.textContent = state.player.score;
            ui.gameOverTitle.textContent = 'GAME OVER';
            ui.gameOverTitle.className = GAME_OVER_TITLE_CLASS;
            const messages = Array.isArray(CONFIG.gameOverMessages) ? CONFIG.gameOverMessages : [];
            ui.gameOverMark.textContent = messages.length ? getRandomItem(messages) : 'Good try!';
            ui.gameOverMark.className = GAME_OVER_MARK_CLASS;
            ui.gameOverDescription.textContent = 'You ran out of hearts...';
            showScreen('game-over');
            playToneSequence(
                CONFIG.audio.gameOverToneFreqsHz,
                CONFIG.audio.gameOverToneType,
                CONFIG.audio.gameOverToneDurationSec,
                CONFIG.audio.gameOverToneDelayMs
            );
        }

        function victory() {
            state.status = 'GAMEOVER';
            saveScore(
                state.player.name,
                state.player.score,
                CONFIG.stages.length - 1,
                CONFIG.stages[CONFIG.stages.length - 1].levels - 1
            );
            
            ui.finalScore.textContent = state.player.score;
            ui.gameOverTitle.textContent = 'VICTORY!';
            ui.gameOverTitle.className = VICTORY_TITLE_CLASS;
            ui.gameOverMark.textContent = 'ðŸ†';
            ui.gameOverMark.className = VICTORY_MARK_CLASS;
            ui.gameOverDescription.textContent = 'You completed all stages!';
            
            showScreen('game-over');
            playToneSequence(
                CONFIG.audio.victoryToneFreqsHz,
                CONFIG.audio.victoryToneType,
                CONFIG.audio.victoryToneDurationSec,
                CONFIG.audio.victoryToneDelayMs
            );
        }

        /**
         * PERSISTENCE & LEADERBOARD
         */
        function getLeaderboard() {
            const data = localStorage.getItem(CONFIG.localStorageKey);
            return data ? JSON.parse(data) : [];
        }

        function saveScore(name, score, stageIndex, levelIndex) {
            let lb = getLeaderboard();
            const stage = Number.isInteger(stageIndex) ? stageIndex + 1 : null;
            const level = Number.isInteger(levelIndex) ? levelIndex + 1 : null;
            
            // Check if user exists, update if score higher
            const existingIndex = lb.findIndex(entry => entry.name === name);
            if (existingIndex > -1) {
                if (score > lb[existingIndex].score) {
                    lb[existingIndex].score = score;
                    lb[existingIndex].stage = stage;
                    lb[existingIndex].level = level;
                    lb[existingIndex].date = new Date().toISOString();
                }
            } else {
                lb.push({ name, score, stage, level, date: new Date().toISOString() });
            }

            // Sort
            lb.sort((a, b) => b.score - a.score);
            
            // Limit size
            lb = lb.slice(0, CONFIG.leaderboard.maxEntries);

            localStorage.setItem(CONFIG.localStorageKey, JSON.stringify(lb));
            updateMiniHighScore();
        }

        function updateMiniHighScore() {
            const lb = getLeaderboard();
            const high = lb.length > 0 ? lb[0].score : 0;
            ui.highScoreMini.textContent = `HI: ${high}`;
        }

        function showLeaderboard() {
            const lb = getLeaderboard();
            ui.leaderboardBody.innerHTML = '';
            
            if (lb.length === 0) {
                ui.leaderboardBody.innerHTML = '<tr><td colspan="4" class="p-4 text-center text-gray-500">No scores yet. Be the first!</td></tr>';
            } else {
                lb.forEach((entry, idx) => {
                    const row = document.createElement('tr');
                    row.className = idx < CONFIG.leaderboard.highlightTopCount
                        ? 'text-yellow-400 font-bold bg-gray-700/30 border-b border-gray-700'
                        : 'text-gray-300 border-b border-gray-700';
                    const icon = CONFIG.leaderboard.topRankIcons[idx]
                        ? `${CONFIG.leaderboard.topRankIcons[idx]} `
                        : '';
                    const stageText = entry.stage ? `S${entry.stage}` : '--';
                    const levelText = entry.level ? `L${entry.level}` : '--';
                    
                    row.innerHTML = `
                        <td class="p-3">${icon}#${idx + 1}</td>
                        <td class="p-3 truncate max-w-[120px]">${entry.name}</td>
                        <td class="p-3 font-mono">${stageText} ${levelText}</td>
                        <td class="p-3 text-right font-mono">${entry.score}</td>
                    `;
                    ui.leaderboardBody.appendChild(row);
                });
            }
            screens.leaderboard.classList.remove('hidden');
        }

        function hideLeaderboard() {
            screens.leaderboard.classList.add('hidden');
        }

        function resetData() {
            if(confirm("Clear all leaderboard data? This cannot be undone.")) {
                localStorage.removeItem(CONFIG.localStorageKey);
                showLeaderboard(); // Refresh view
                updateMiniHighScore();
            }
        }

        /**
         * UTILS & AUDIO
         */
        function showScreen(screenName) {
            Object.values(screens).forEach(s => s.classList.add('hidden'));
            if (screenName === 'menu') screens.menu.classList.remove('hidden');
            if (screenName === 'stage') screens.stage.classList.remove('hidden');
            if (screenName === 'game') screens.game.classList.remove('hidden');
            if (screenName === 'howto') screens.howto.classList.remove('hidden');
            if (screenName === 'game-over') screens.gameOver.classList.remove('hidden');

            if (screenName === 'game') {
                ui.header.classList.remove('hidden');
            } else {
                ui.header.classList.add('hidden');
            }
        }

        // Simple Web Audio API for feedback
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playTone(freq, type, duration) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            
            gain.gain.setValueAtTime(CONFIG.audio.gainStart, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(CONFIG.audio.gainEnd, audioCtx.currentTime + duration);
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }
        
        function playToneSequence(freqs, type, duration, delayMs) {
            if (!Array.isArray(freqs) || freqs.length === 0) return;
            freqs.forEach((freq, index) => {
                setTimeout(() => {
                    playTone(freq, type, duration);
                }, index * delayMs);
            });
        }

        function getRandomItem(items) {
            return items[Math.floor(Math.random() * items.length)];
        }

        // Init
        init();

    </script>
</body>
</html>
